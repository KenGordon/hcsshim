// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/Microsoft/hcsshim/internal/vmservice/vmservice.proto

package vmservice

import (
	context "context"
	fmt "fmt"
	github_com_containerd_ttrpc "github.com/containerd/ttrpc"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//
// Modify existing VM request/response
//
type ModifyType int32

const (
	ModifyType_ADD    ModifyType = 0
	ModifyType_REMOVE ModifyType = 1
	ModifyType_UPDATE ModifyType = 2
)

var ModifyType_name = map[int32]string{
	0: "ADD",
	1: "REMOVE",
	2: "UPDATE",
}

var ModifyType_value = map[string]int32{
	"ADD":    0,
	"REMOVE": 1,
	"UPDATE": 2,
}

func (x ModifyType) String() string {
	return proto.EnumName(ModifyType_name, int32(x))
}

func (ModifyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{0}
}

type DiskType int32

const (
	DiskType_SCSI_DISK_TYPE_VHD1     DiskType = 0
	DiskType_SCSI_DISK_TYPE_VHDX     DiskType = 1
	DiskType_SCSI_DISK_TYPE_PHYSICAL DiskType = 2
)

var DiskType_name = map[int32]string{
	0: "SCSI_DISK_TYPE_VHD1",
	1: "SCSI_DISK_TYPE_VHDX",
	2: "SCSI_DISK_TYPE_PHYSICAL",
}

var DiskType_value = map[string]int32{
	"SCSI_DISK_TYPE_VHD1":     0,
	"SCSI_DISK_TYPE_VHDX":     1,
	"SCSI_DISK_TYPE_PHYSICAL": 2,
}

func (x DiskType) String() string {
	return proto.EnumName(DiskType_name, int32(x))
}

func (DiskType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{1}
}

type MemoryConfig_BackingType int32

const (
	MemoryConfig_PHYSICAL MemoryConfig_BackingType = 0
	MemoryConfig_VIRTUAL  MemoryConfig_BackingType = 1
)

var MemoryConfig_BackingType_name = map[int32]string{
	0: "PHYSICAL",
	1: "VIRTUAL",
}

var MemoryConfig_BackingType_value = map[string]int32{
	"PHYSICAL": 0,
	"VIRTUAL":  1,
}

func (x MemoryConfig_BackingType) String() string {
	return proto.EnumName(MemoryConfig_BackingType_name, int32(x))
}

func (MemoryConfig_BackingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{2, 0}
}

type PropertiesVMRequest_PropertiesType int32

const (
	PropertiesVMRequest_Memory    PropertiesVMRequest_PropertiesType = 0
	PropertiesVMRequest_Processor PropertiesVMRequest_PropertiesType = 1
)

var PropertiesVMRequest_PropertiesType_name = map[int32]string{
	0: "Memory",
	1: "Processor",
}

var PropertiesVMRequest_PropertiesType_value = map[string]int32{
	"Memory":    0,
	"Processor": 1,
}

func (x PropertiesVMRequest_PropertiesType) String() string {
	return proto.EnumName(PropertiesVMRequest_PropertiesType_name, int32(x))
}

func (PropertiesVMRequest_PropertiesType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{12, 0}
}

// For a resource to be "supported", should the full classic matrix
// of add, remove, update be supported? e.g. if adding and removing a nic
// but not updating it at runtime is supported, is it supported?
// I'd tried an approach without the bools in SupportedResource.
type CapabilitiesVMResponse_Resource int32

const (
	CapabilitiesVMResponse_Vpmem CapabilitiesVMResponse_Resource = 0
	CapabilitiesVMResponse_Scsi  CapabilitiesVMResponse_Resource = 1
	CapabilitiesVMResponse_Vpci  CapabilitiesVMResponse_Resource = 2
	CapabilitiesVMResponse_Plan9 CapabilitiesVMResponse_Resource = 3
	CapabilitiesVMResponse_VMNic CapabilitiesVMResponse_Resource = 4
)

var CapabilitiesVMResponse_Resource_name = map[int32]string{
	0: "Vpmem",
	1: "Scsi",
	2: "Vpci",
	3: "Plan9",
	4: "VMNic",
}

var CapabilitiesVMResponse_Resource_value = map[string]int32{
	"Vpmem": 0,
	"Scsi":  1,
	"Vpci":  2,
	"Plan9": 3,
	"VMNic": 4,
}

func (x CapabilitiesVMResponse_Resource) String() string {
	return proto.EnumName(CapabilitiesVMResponse_Resource_name, int32(x))
}

func (CapabilitiesVMResponse_Resource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{14, 0}
}

type CapabilitiesVMResponse_SupportedGuestOS int32

const (
	CapabilitiesVMResponse_Windows CapabilitiesVMResponse_SupportedGuestOS = 0
	CapabilitiesVMResponse_Linux   CapabilitiesVMResponse_SupportedGuestOS = 1
)

var CapabilitiesVMResponse_SupportedGuestOS_name = map[int32]string{
	0: "Windows",
	1: "Linux",
}

var CapabilitiesVMResponse_SupportedGuestOS_value = map[string]int32{
	"Windows": 0,
	"Linux":   1,
}

func (x CapabilitiesVMResponse_SupportedGuestOS) String() string {
	return proto.EnumName(CapabilitiesVMResponse_SupportedGuestOS_name, int32(x))
}

func (CapabilitiesVMResponse_SupportedGuestOS) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{14, 1}
}

//
// VM lifecycle request/response
//
type DirectBoot struct {
	KernelPath           string   `protobuf:"bytes,1,opt,name=kernel_path,json=kernelPath,proto3" json:"kernel_path,omitempty"`
	InitrdPath           string   `protobuf:"bytes,2,opt,name=initrd_path,json=initrdPath,proto3" json:"initrd_path,omitempty"`
	KernelCmdline        string   `protobuf:"bytes,3,opt,name=kernel_cmdline,json=kernelCmdline,proto3" json:"kernel_cmdline,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DirectBoot) Reset()      { *m = DirectBoot{} }
func (*DirectBoot) ProtoMessage() {}
func (*DirectBoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{0}
}
func (m *DirectBoot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectBoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectBoot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectBoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectBoot.Merge(m, src)
}
func (m *DirectBoot) XXX_Size() int {
	return m.Size()
}
func (m *DirectBoot) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectBoot.DiscardUnknown(m)
}

var xxx_messageInfo_DirectBoot proto.InternalMessageInfo

type UEFI struct {
	FirmwarePath string `protobuf:"bytes,1,opt,name=firmware_path,json=firmwarePath,proto3" json:"firmware_path,omitempty"`
	DevicePath   string `protobuf:"bytes,2,opt,name=device_path,json=devicePath,proto3" json:"device_path,omitempty"`
	// Optional data to include for uefi boot. For Linux this could be used as the kernel
	// commandline.
	OptionalData         string   `protobuf:"bytes,3,opt,name=optional_data,json=optionalData,proto3" json:"optional_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UEFI) Reset()      { *m = UEFI{} }
func (*UEFI) ProtoMessage() {}
func (*UEFI) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{1}
}
func (m *UEFI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEFI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEFI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEFI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEFI.Merge(m, src)
}
func (m *UEFI) XXX_Size() int {
	return m.Size()
}
func (m *UEFI) XXX_DiscardUnknown() {
	xxx_messageInfo_UEFI.DiscardUnknown(m)
}

var xxx_messageInfo_UEFI proto.InternalMessageInfo

type MemoryConfig struct {
	MemoryMb             uint64                   `protobuf:"varint,1,opt,name=memory_mb,json=memoryMb,proto3" json:"memory_mb,omitempty"`
	BackingType          MemoryConfig_BackingType `protobuf:"varint,2,opt,name=backing_type,json=backingType,proto3,enum=vmservice.MemoryConfig_BackingType" json:"backing_type,omitempty"`
	LowMmioGapInMb       uint64                   `protobuf:"varint,3,opt,name=low_mmio_gap_in_mb,json=lowMmioGapInMb,proto3" json:"low_mmio_gap_in_mb,omitempty"`
	HighMmioBaseInMb     uint64                   `protobuf:"varint,4,opt,name=high_mmio_base_in_mb,json=highMmioBaseInMb,proto3" json:"high_mmio_base_in_mb,omitempty"`
	HighMmioGapInMb      uint64                   `protobuf:"varint,5,opt,name=high_mmio_gap_in_mb,json=highMmioGapInMb,proto3" json:"high_mmio_gap_in_mb,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *MemoryConfig) Reset()      { *m = MemoryConfig{} }
func (*MemoryConfig) ProtoMessage() {}
func (*MemoryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{2}
}
func (m *MemoryConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryConfig.Merge(m, src)
}
func (m *MemoryConfig) XXX_Size() int {
	return m.Size()
}
func (m *MemoryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryConfig proto.InternalMessageInfo

type ProcessorConfig struct {
	ProcessorCount       uint32   `protobuf:"varint,1,opt,name=processor_count,json=processorCount,proto3" json:"processor_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProcessorConfig) Reset()      { *m = ProcessorConfig{} }
func (*ProcessorConfig) ProtoMessage() {}
func (*ProcessorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{3}
}
func (m *ProcessorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessorConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorConfig.Merge(m, src)
}
func (m *ProcessorConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorConfig proto.InternalMessageInfo

type DevicesConfig struct {
	ScsiDisks  []*SCSIDisk  `protobuf:"bytes,1,rep,name=scsi_disks,json=scsiDisks,proto3" json:"scsi_disks,omitempty"`
	VpmemDisks []*VPMEMDisk `protobuf:"bytes,2,rep,name=vpmem_disks,json=vpmemDisks,proto3" json:"vpmem_disks,omitempty"`
	NicConfig  []*NICConfig `protobuf:"bytes,3,rep,name=nic_config,json=nicConfig,proto3" json:"nic_config,omitempty"`
	// When we know what information we need to assign a pci device on Linux,
	// have a oneof here named PCIDevice with WindowsPCIDevice and LinuxPCIDevice
	// housed.
	WindowsDevice        []*WindowsPCIDevice `protobuf:"bytes,4,rep,name=windows_device,json=windowsDevice,proto3" json:"windows_device,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *DevicesConfig) Reset()      { *m = DevicesConfig{} }
func (*DevicesConfig) ProtoMessage() {}
func (*DevicesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{4}
}
func (m *DevicesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DevicesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DevicesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DevicesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DevicesConfig.Merge(m, src)
}
func (m *DevicesConfig) XXX_Size() int {
	return m.Size()
}
func (m *DevicesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DevicesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DevicesConfig proto.InternalMessageInfo

type VMConfig struct {
	MemoryConfig    *MemoryConfig    `protobuf:"bytes,1,opt,name=memory_config,json=memoryConfig,proto3" json:"memory_config,omitempty"`
	ProcessorConfig *ProcessorConfig `protobuf:"bytes,2,opt,name=processor_config,json=processorConfig,proto3" json:"processor_config,omitempty"`
	DevicesConfig   *DevicesConfig   `protobuf:"bytes,3,opt,name=devices_config,json=devicesConfig,proto3" json:"devices_config,omitempty"`
	SerialConfig    *SerialConfig    `protobuf:"bytes,4,opt,name=serial_config,json=serialConfig,proto3" json:"serial_config,omitempty"`
	// Types that are valid to be assigned to BootConfig:
	//	*VMConfig_DirectBoot
	//	*VMConfig_Uefi
	BootConfig isVMConfig_BootConfig `protobuf_oneof:"BootConfig"`
	// Optional k:v extra data. Up to the virtstack for how to interpret this.
	ExtraData            map[string]string `protobuf:"bytes,7,rep,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *VMConfig) Reset()      { *m = VMConfig{} }
func (*VMConfig) ProtoMessage() {}
func (*VMConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{5}
}
func (m *VMConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VMConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VMConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMConfig.Merge(m, src)
}
func (m *VMConfig) XXX_Size() int {
	return m.Size()
}
func (m *VMConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VMConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VMConfig proto.InternalMessageInfo

type isVMConfig_BootConfig interface {
	isVMConfig_BootConfig()
	MarshalTo([]byte) (int, error)
	Size() int
}

type VMConfig_DirectBoot struct {
	DirectBoot *DirectBoot `protobuf:"bytes,5,opt,name=direct_boot,json=directBoot,proto3,oneof"`
}
type VMConfig_Uefi struct {
	Uefi *UEFI `protobuf:"bytes,6,opt,name=uefi,proto3,oneof"`
}

func (*VMConfig_DirectBoot) isVMConfig_BootConfig() {}
func (*VMConfig_Uefi) isVMConfig_BootConfig()       {}

func (m *VMConfig) GetBootConfig() isVMConfig_BootConfig {
	if m != nil {
		return m.BootConfig
	}
	return nil
}

func (m *VMConfig) GetDirectBoot() *DirectBoot {
	if x, ok := m.GetBootConfig().(*VMConfig_DirectBoot); ok {
		return x.DirectBoot
	}
	return nil
}

func (m *VMConfig) GetUefi() *UEFI {
	if x, ok := m.GetBootConfig().(*VMConfig_Uefi); ok {
		return x.Uefi
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VMConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VMConfig_OneofMarshaler, _VMConfig_OneofUnmarshaler, _VMConfig_OneofSizer, []interface{}{
		(*VMConfig_DirectBoot)(nil),
		(*VMConfig_Uefi)(nil),
	}
}

func _VMConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VMConfig)
	// BootConfig
	switch x := m.BootConfig.(type) {
	case *VMConfig_DirectBoot:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DirectBoot); err != nil {
			return err
		}
	case *VMConfig_Uefi:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Uefi); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VMConfig.BootConfig has unexpected type %T", x)
	}
	return nil
}

func _VMConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VMConfig)
	switch tag {
	case 5: // BootConfig.direct_boot
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DirectBoot)
		err := b.DecodeMessage(msg)
		m.BootConfig = &VMConfig_DirectBoot{msg}
		return true, err
	case 6: // BootConfig.uefi
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UEFI)
		err := b.DecodeMessage(msg)
		m.BootConfig = &VMConfig_Uefi{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VMConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VMConfig)
	// BootConfig
	switch x := m.BootConfig.(type) {
	case *VMConfig_DirectBoot:
		s := proto.Size(x.DirectBoot)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VMConfig_Uefi:
		s := proto.Size(x.Uefi)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SerialConfig struct {
	Ports                []*SerialConfig_Config `protobuf:"bytes,3,rep,name=ports,proto3" json:"ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SerialConfig) Reset()      { *m = SerialConfig{} }
func (*SerialConfig) ProtoMessage() {}
func (*SerialConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{6}
}
func (m *SerialConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SerialConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SerialConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SerialConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SerialConfig.Merge(m, src)
}
func (m *SerialConfig) XXX_Size() int {
	return m.Size()
}
func (m *SerialConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SerialConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SerialConfig proto.InternalMessageInfo

type SerialConfig_Config struct {
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// Uds to relay serial console output to.
	SocketPath           string   `protobuf:"bytes,2,opt,name=socket_path,json=socketPath,proto3" json:"socket_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SerialConfig_Config) Reset()      { *m = SerialConfig_Config{} }
func (*SerialConfig_Config) ProtoMessage() {}
func (*SerialConfig_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{6, 0}
}
func (m *SerialConfig_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SerialConfig_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SerialConfig_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SerialConfig_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SerialConfig_Config.Merge(m, src)
}
func (m *SerialConfig_Config) XXX_Size() int {
	return m.Size()
}
func (m *SerialConfig_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_SerialConfig_Config.DiscardUnknown(m)
}

var xxx_messageInfo_SerialConfig_Config proto.InternalMessageInfo

type CreateVMRequest struct {
	Config *VMConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	// Optional ID to be used by the VM service in log messages. It's up to the
	// server/virtstack to make use of this field. Useful for debugging to be able to
	// correlate events in the virtstack for a given vm that the client launched.
	LogID                string   `protobuf:"bytes,2,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVMRequest) Reset()      { *m = CreateVMRequest{} }
func (*CreateVMRequest) ProtoMessage() {}
func (*CreateVMRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{7}
}
func (m *CreateVMRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateVMRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateVMRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateVMRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVMRequest.Merge(m, src)
}
func (m *CreateVMRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateVMRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVMRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVMRequest proto.InternalMessageInfo

type InspectVMRequest struct {
	Query                string   `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	RecursionLimit       uint32   `protobuf:"varint,2,opt,name=recursion_limit,json=recursionLimit,proto3" json:"recursion_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectVMRequest) Reset()      { *m = InspectVMRequest{} }
func (*InspectVMRequest) ProtoMessage() {}
func (*InspectVMRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{8}
}
func (m *InspectVMRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectVMRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectVMRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectVMRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectVMRequest.Merge(m, src)
}
func (m *InspectVMRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectVMRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectVMRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectVMRequest proto.InternalMessageInfo

type InspectVMResponse struct {
	Result               *types.Value `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *InspectVMResponse) Reset()      { *m = InspectVMResponse{} }
func (*InspectVMResponse) ProtoMessage() {}
func (*InspectVMResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{9}
}
func (m *InspectVMResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectVMResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectVMResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectVMResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectVMResponse.Merge(m, src)
}
func (m *InspectVMResponse) XXX_Size() int {
	return m.Size()
}
func (m *InspectVMResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectVMResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InspectVMResponse proto.InternalMessageInfo

type MemoryStats struct {
	WorkingSetBytes      uint64   `protobuf:"varint,1,opt,name=WorkingSetBytes,proto3" json:"WorkingSetBytes,omitempty"`
	AvailableMemory      uint64   `protobuf:"varint,2,opt,name=AvailableMemory,proto3" json:"AvailableMemory,omitempty"`
	ReservedMemory       uint64   `protobuf:"varint,3,opt,name=ReservedMemory,proto3" json:"ReservedMemory,omitempty"`
	AssignedMemory       uint64   `protobuf:"varint,4,opt,name=AssignedMemory,proto3" json:"AssignedMemory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoryStats) Reset()      { *m = MemoryStats{} }
func (*MemoryStats) ProtoMessage() {}
func (*MemoryStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{10}
}
func (m *MemoryStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryStats.Merge(m, src)
}
func (m *MemoryStats) XXX_Size() int {
	return m.Size()
}
func (m *MemoryStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryStats.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryStats proto.InternalMessageInfo

type ProcessorStats struct {
	TotalRuntime         uint64   `protobuf:"varint,1,opt,name=TotalRuntime,proto3" json:"TotalRuntime,omitempty"`
	RuntimeUser          uint64   `protobuf:"varint,2,opt,name=RuntimeUser,proto3" json:"RuntimeUser,omitempty"`
	RuntimeKernel        uint64   `protobuf:"varint,3,opt,name=RuntimeKernel,proto3" json:"RuntimeKernel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProcessorStats) Reset()      { *m = ProcessorStats{} }
func (*ProcessorStats) ProtoMessage() {}
func (*ProcessorStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{11}
}
func (m *ProcessorStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessorStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessorStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorStats.Merge(m, src)
}
func (m *ProcessorStats) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorStats.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorStats proto.InternalMessageInfo

type PropertiesVMRequest struct {
	Types                []PropertiesVMRequest_PropertiesType `protobuf:"varint,1,rep,packed,name=types,proto3,enum=vmservice.PropertiesVMRequest_PropertiesType" json:"types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *PropertiesVMRequest) Reset()      { *m = PropertiesVMRequest{} }
func (*PropertiesVMRequest) ProtoMessage() {}
func (*PropertiesVMRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{12}
}
func (m *PropertiesVMRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertiesVMRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertiesVMRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertiesVMRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertiesVMRequest.Merge(m, src)
}
func (m *PropertiesVMRequest) XXX_Size() int {
	return m.Size()
}
func (m *PropertiesVMRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertiesVMRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PropertiesVMRequest proto.InternalMessageInfo

type PropertiesVMResponse struct {
	MemoryStats          *MemoryStats    `protobuf:"bytes,1,opt,name=memory_stats,json=memoryStats,proto3" json:"memory_stats,omitempty"`
	ProcessorStats       *ProcessorStats `protobuf:"bytes,2,opt,name=processor_stats,json=processorStats,proto3" json:"processor_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PropertiesVMResponse) Reset()      { *m = PropertiesVMResponse{} }
func (*PropertiesVMResponse) ProtoMessage() {}
func (*PropertiesVMResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{13}
}
func (m *PropertiesVMResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertiesVMResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertiesVMResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertiesVMResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertiesVMResponse.Merge(m, src)
}
func (m *PropertiesVMResponse) XXX_Size() int {
	return m.Size()
}
func (m *PropertiesVMResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertiesVMResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PropertiesVMResponse proto.InternalMessageInfo

// Q: Should this just return what's supported on the host OS? For example if device assignment worked
// on a Windows host, but not on Linux should we have a Linux and Windows capabilities section and only fill in
// true for Windows and leave Linux blank, or do we just want this to return whatever is good to go on the host OS.
// I guess the windows vs linux sections would help not having to define windows specific resources in the Resource
// enum (vsmb) which I haven't as of now.
type CapabilitiesVMResponse struct {
	SupportedResources   []*CapabilitiesVMResponse_SupportedResource `protobuf:"bytes,1,rep,name=supported_resources,json=supportedResources,proto3" json:"supported_resources,omitempty"`
	SupportedGuestOs     []CapabilitiesVMResponse_SupportedGuestOS   `protobuf:"varint,2,rep,packed,name=supported_guest_os,json=supportedGuestOs,proto3,enum=vmservice.CapabilitiesVMResponse_SupportedGuestOS" json:"supported_guest_os,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *CapabilitiesVMResponse) Reset()      { *m = CapabilitiesVMResponse{} }
func (*CapabilitiesVMResponse) ProtoMessage() {}
func (*CapabilitiesVMResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{14}
}
func (m *CapabilitiesVMResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapabilitiesVMResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CapabilitiesVMResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CapabilitiesVMResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapabilitiesVMResponse.Merge(m, src)
}
func (m *CapabilitiesVMResponse) XXX_Size() int {
	return m.Size()
}
func (m *CapabilitiesVMResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CapabilitiesVMResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CapabilitiesVMResponse proto.InternalMessageInfo

type CapabilitiesVMResponse_SupportedResource struct {
	Add                  bool                            `protobuf:"varint,1,opt,name=Add,proto3" json:"Add,omitempty"`
	Remove               bool                            `protobuf:"varint,2,opt,name=Remove,proto3" json:"Remove,omitempty"`
	Update               bool                            `protobuf:"varint,3,opt,name=Update,proto3" json:"Update,omitempty"`
	Resource             CapabilitiesVMResponse_Resource `protobuf:"varint,4,opt,name=resource,proto3,enum=vmservice.CapabilitiesVMResponse_Resource" json:"resource,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *CapabilitiesVMResponse_SupportedResource) Reset() {
	*m = CapabilitiesVMResponse_SupportedResource{}
}
func (*CapabilitiesVMResponse_SupportedResource) ProtoMessage() {}
func (*CapabilitiesVMResponse_SupportedResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{14, 0}
}
func (m *CapabilitiesVMResponse_SupportedResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapabilitiesVMResponse_SupportedResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CapabilitiesVMResponse_SupportedResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CapabilitiesVMResponse_SupportedResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapabilitiesVMResponse_SupportedResource.Merge(m, src)
}
func (m *CapabilitiesVMResponse_SupportedResource) XXX_Size() int {
	return m.Size()
}
func (m *CapabilitiesVMResponse_SupportedResource) XXX_DiscardUnknown() {
	xxx_messageInfo_CapabilitiesVMResponse_SupportedResource.DiscardUnknown(m)
}

var xxx_messageInfo_CapabilitiesVMResponse_SupportedResource proto.InternalMessageInfo

type HVSocketListen struct {
	ServiceID string `protobuf:"bytes,1,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	// Expected that the listener is a unix domain socket. These
	// are supported on Windows as of 1809/RS5.
	ListenerPath         string   `protobuf:"bytes,2,opt,name=listener_path,json=listenerPath,proto3" json:"listener_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HVSocketListen) Reset()      { *m = HVSocketListen{} }
func (*HVSocketListen) ProtoMessage() {}
func (*HVSocketListen) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{15}
}
func (m *HVSocketListen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HVSocketListen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HVSocketListen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HVSocketListen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HVSocketListen.Merge(m, src)
}
func (m *HVSocketListen) XXX_Size() int {
	return m.Size()
}
func (m *HVSocketListen) XXX_DiscardUnknown() {
	xxx_messageInfo_HVSocketListen.DiscardUnknown(m)
}

var xxx_messageInfo_HVSocketListen proto.InternalMessageInfo

type VSockListen struct {
	Port                 uint32   `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	ListenerPath         string   `protobuf:"bytes,2,opt,name=listener_path,json=listenerPath,proto3" json:"listener_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VSockListen) Reset()      { *m = VSockListen{} }
func (*VSockListen) ProtoMessage() {}
func (*VSockListen) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{16}
}
func (m *VSockListen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VSockListen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VSockListen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VSockListen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VSockListen.Merge(m, src)
}
func (m *VSockListen) XXX_Size() int {
	return m.Size()
}
func (m *VSockListen) XXX_DiscardUnknown() {
	xxx_messageInfo_VSockListen.DiscardUnknown(m)
}

var xxx_messageInfo_VSockListen proto.InternalMessageInfo

// Abstraction around a hypervisor socket transport (Hvsocket, Vsock)
type VMSocketRequest struct {
	// Just add and remove, no update.
	Type ModifyType `protobuf:"varint,1,opt,name=type,proto3,enum=vmservice.ModifyType" json:"type,omitempty"`
	// Types that are valid to be assigned to Config:
	//	*VMSocketRequest_HvsocketList
	//	*VMSocketRequest_VsockListen
	Config               isVMSocketRequest_Config `protobuf_oneof:"Config"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *VMSocketRequest) Reset()      { *m = VMSocketRequest{} }
func (*VMSocketRequest) ProtoMessage() {}
func (*VMSocketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{17}
}
func (m *VMSocketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMSocketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VMSocketRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VMSocketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMSocketRequest.Merge(m, src)
}
func (m *VMSocketRequest) XXX_Size() int {
	return m.Size()
}
func (m *VMSocketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VMSocketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VMSocketRequest proto.InternalMessageInfo

type isVMSocketRequest_Config interface {
	isVMSocketRequest_Config()
	MarshalTo([]byte) (int, error)
	Size() int
}

type VMSocketRequest_HvsocketList struct {
	HvsocketList *HVSocketListen `protobuf:"bytes,2,opt,name=hvsocket_list,json=hvsocketList,proto3,oneof"`
}
type VMSocketRequest_VsockListen struct {
	VsockListen *VSockListen `protobuf:"bytes,3,opt,name=vsock_listen,json=vsockListen,proto3,oneof"`
}

func (*VMSocketRequest_HvsocketList) isVMSocketRequest_Config() {}
func (*VMSocketRequest_VsockListen) isVMSocketRequest_Config()  {}

func (m *VMSocketRequest) GetConfig() isVMSocketRequest_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *VMSocketRequest) GetHvsocketList() *HVSocketListen {
	if x, ok := m.GetConfig().(*VMSocketRequest_HvsocketList); ok {
		return x.HvsocketList
	}
	return nil
}

func (m *VMSocketRequest) GetVsockListen() *VSockListen {
	if x, ok := m.GetConfig().(*VMSocketRequest_VsockListen); ok {
		return x.VsockListen
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*VMSocketRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _VMSocketRequest_OneofMarshaler, _VMSocketRequest_OneofUnmarshaler, _VMSocketRequest_OneofSizer, []interface{}{
		(*VMSocketRequest_HvsocketList)(nil),
		(*VMSocketRequest_VsockListen)(nil),
	}
}

func _VMSocketRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*VMSocketRequest)
	// Config
	switch x := m.Config.(type) {
	case *VMSocketRequest_HvsocketList:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HvsocketList); err != nil {
			return err
		}
	case *VMSocketRequest_VsockListen:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VsockListen); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("VMSocketRequest.Config has unexpected type %T", x)
	}
	return nil
}

func _VMSocketRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*VMSocketRequest)
	switch tag {
	case 2: // Config.hvsocket_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HVSocketListen)
		err := b.DecodeMessage(msg)
		m.Config = &VMSocketRequest_HvsocketList{msg}
		return true, err
	case 3: // Config.vsock_listen
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VSockListen)
		err := b.DecodeMessage(msg)
		m.Config = &VMSocketRequest_VsockListen{msg}
		return true, err
	default:
		return false, nil
	}
}

func _VMSocketRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*VMSocketRequest)
	// Config
	switch x := m.Config.(type) {
	case *VMSocketRequest_HvsocketList:
		s := proto.Size(x.HvsocketList)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *VMSocketRequest_VsockListen:
		s := proto.Size(x.VsockListen)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SCSIDisk struct {
	Controller           uint32   `protobuf:"varint,1,opt,name=controller,proto3" json:"controller,omitempty"`
	Lun                  uint32   `protobuf:"varint,2,opt,name=lun,proto3" json:"lun,omitempty"`
	HostPath             string   `protobuf:"bytes,3,opt,name=host_path,json=hostPath,proto3" json:"host_path,omitempty"`
	Type                 DiskType `protobuf:"varint,4,opt,name=type,proto3,enum=vmservice.DiskType" json:"type,omitempty"`
	ReadOnly             bool     `protobuf:"varint,5,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SCSIDisk) Reset()      { *m = SCSIDisk{} }
func (*SCSIDisk) ProtoMessage() {}
func (*SCSIDisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{18}
}
func (m *SCSIDisk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCSIDisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCSIDisk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCSIDisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCSIDisk.Merge(m, src)
}
func (m *SCSIDisk) XXX_Size() int {
	return m.Size()
}
func (m *SCSIDisk) XXX_DiscardUnknown() {
	xxx_messageInfo_SCSIDisk.DiscardUnknown(m)
}

var xxx_messageInfo_SCSIDisk proto.InternalMessageInfo

type VPMEMDisk struct {
	HostPath             string   `protobuf:"bytes,1,opt,name=host_path,json=hostPath,proto3" json:"host_path,omitempty"`
	Type                 DiskType `protobuf:"varint,2,opt,name=type,proto3,enum=vmservice.DiskType" json:"type,omitempty"`
	ReadOnly             bool     `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VPMEMDisk) Reset()      { *m = VPMEMDisk{} }
func (*VPMEMDisk) ProtoMessage() {}
func (*VPMEMDisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{19}
}
func (m *VPMEMDisk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VPMEMDisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VPMEMDisk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VPMEMDisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VPMEMDisk.Merge(m, src)
}
func (m *VPMEMDisk) XXX_Size() int {
	return m.Size()
}
func (m *VPMEMDisk) XXX_DiscardUnknown() {
	xxx_messageInfo_VPMEMDisk.DiscardUnknown(m)
}

var xxx_messageInfo_VPMEMDisk proto.InternalMessageInfo

type ModifySCSIDiskRequest struct {
	Type                 ModifyType `protobuf:"varint,1,opt,name=type,proto3,enum=vmservice.ModifyType" json:"type,omitempty"`
	Disk                 *SCSIDisk  `protobuf:"bytes,2,opt,name=disk,proto3" json:"disk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ModifySCSIDiskRequest) Reset()      { *m = ModifySCSIDiskRequest{} }
func (*ModifySCSIDiskRequest) ProtoMessage() {}
func (*ModifySCSIDiskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{20}
}
func (m *ModifySCSIDiskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifySCSIDiskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifySCSIDiskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifySCSIDiskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifySCSIDiskRequest.Merge(m, src)
}
func (m *ModifySCSIDiskRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModifySCSIDiskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifySCSIDiskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifySCSIDiskRequest proto.InternalMessageInfo

type ModifyVPMEMDiskRequest struct {
	Type                 ModifyType `protobuf:"varint,1,opt,name=type,proto3,enum=vmservice.ModifyType" json:"type,omitempty"`
	Disk                 *VPMEMDisk `protobuf:"bytes,2,opt,name=disk,proto3" json:"disk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ModifyVPMEMDiskRequest) Reset()      { *m = ModifyVPMEMDiskRequest{} }
func (*ModifyVPMEMDiskRequest) ProtoMessage() {}
func (*ModifyVPMEMDiskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{21}
}
func (m *ModifyVPMEMDiskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyVPMEMDiskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyVPMEMDiskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyVPMEMDiskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyVPMEMDiskRequest.Merge(m, src)
}
func (m *ModifyVPMEMDiskRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModifyVPMEMDiskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyVPMEMDiskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyVPMEMDiskRequest proto.InternalMessageInfo

type NICConfig struct {
	NicID      string `protobuf:"bytes,1,opt,name=nic_id,json=nicId,proto3" json:"nic_id,omitempty"`
	PortID     string `protobuf:"bytes,2,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	MacAddress string `protobuf:"bytes,3,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	SwitchID   string `protobuf:"bytes,4,opt,name=switch_id,json=switchId,proto3" json:"switch_id,omitempty"`
	// Optional friendly name for the adapter. Might be useful to show up in logs.
	NicName              string   `protobuf:"bytes,5,opt,name=nic_name,json=nicName,proto3" json:"nic_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NICConfig) Reset()      { *m = NICConfig{} }
func (*NICConfig) ProtoMessage() {}
func (*NICConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{22}
}
func (m *NICConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NICConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NICConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NICConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NICConfig.Merge(m, src)
}
func (m *NICConfig) XXX_Size() int {
	return m.Size()
}
func (m *NICConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NICConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NICConfig proto.InternalMessageInfo

type ModifyNICRequest struct {
	Type                 ModifyType `protobuf:"varint,1,opt,name=type,proto3,enum=vmservice.ModifyType" json:"type,omitempty"`
	Nic                  *NICConfig `protobuf:"bytes,2,opt,name=nic,proto3" json:"nic,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ModifyNICRequest) Reset()      { *m = ModifyNICRequest{} }
func (*ModifyNICRequest) ProtoMessage() {}
func (*ModifyNICRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{23}
}
func (m *ModifyNICRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyNICRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyNICRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyNICRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyNICRequest.Merge(m, src)
}
func (m *ModifyNICRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModifyNICRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyNICRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyNICRequest proto.InternalMessageInfo

type WindowsPCIDevice struct {
	// e.g. PCIP\\VEN_10DE&DEV_13F2&SUBSYS_115E10DE&REV_A1\\6&17F903&0&00400000
	InstanceID           string   `protobuf:"bytes,1,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WindowsPCIDevice) Reset()      { *m = WindowsPCIDevice{} }
func (*WindowsPCIDevice) ProtoMessage() {}
func (*WindowsPCIDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{24}
}
func (m *WindowsPCIDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowsPCIDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowsPCIDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowsPCIDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowsPCIDevice.Merge(m, src)
}
func (m *WindowsPCIDevice) XXX_Size() int {
	return m.Size()
}
func (m *WindowsPCIDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowsPCIDevice.DiscardUnknown(m)
}

var xxx_messageInfo_WindowsPCIDevice proto.InternalMessageInfo

type ModifyPCIDeviceRequest struct {
	Type                 ModifyType        `protobuf:"varint,1,opt,name=type,proto3,enum=vmservice.ModifyType" json:"type,omitempty"`
	WindowsPciDevice     *WindowsPCIDevice `protobuf:"bytes,2,opt,name=windows_pci_device,json=windowsPciDevice,proto3" json:"windows_pci_device,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ModifyPCIDeviceRequest) Reset()      { *m = ModifyPCIDeviceRequest{} }
func (*ModifyPCIDeviceRequest) ProtoMessage() {}
func (*ModifyPCIDeviceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{25}
}
func (m *ModifyPCIDeviceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyPCIDeviceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyPCIDeviceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyPCIDeviceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyPCIDeviceRequest.Merge(m, src)
}
func (m *ModifyPCIDeviceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModifyPCIDeviceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyPCIDeviceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyPCIDeviceRequest proto.InternalMessageInfo

type ModifyResourceRequest struct {
	Type ModifyType `protobuf:"varint,1,opt,name=type,proto3,enum=vmservice.ModifyType" json:"type,omitempty"`
	// Types that are valid to be assigned to Resource:
	//	*ModifyResourceRequest_ScsiDisk
	//	*ModifyResourceRequest_VpmemDisk
	//	*ModifyResourceRequest_NicConfig
	//	*ModifyResourceRequest_WindowsDevice
	Resource             isModifyResourceRequest_Resource `protobuf_oneof:"resource"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *ModifyResourceRequest) Reset()      { *m = ModifyResourceRequest{} }
func (*ModifyResourceRequest) ProtoMessage() {}
func (*ModifyResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_272f12cfdaa6c7c8, []int{26}
}
func (m *ModifyResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyResourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyResourceRequest.Merge(m, src)
}
func (m *ModifyResourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModifyResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyResourceRequest proto.InternalMessageInfo

type isModifyResourceRequest_Resource interface {
	isModifyResourceRequest_Resource()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModifyResourceRequest_ScsiDisk struct {
	ScsiDisk *SCSIDisk `protobuf:"bytes,2,opt,name=scsi_disk,json=scsiDisk,proto3,oneof"`
}
type ModifyResourceRequest_VpmemDisk struct {
	VpmemDisk *VPMEMDisk `protobuf:"bytes,3,opt,name=vpmem_disk,json=vpmemDisk,proto3,oneof"`
}
type ModifyResourceRequest_NicConfig struct {
	NicConfig *NICConfig `protobuf:"bytes,4,opt,name=nic_config,json=nicConfig,proto3,oneof"`
}
type ModifyResourceRequest_WindowsDevice struct {
	WindowsDevice *WindowsPCIDevice `protobuf:"bytes,5,opt,name=windows_device,json=windowsDevice,proto3,oneof"`
}

func (*ModifyResourceRequest_ScsiDisk) isModifyResourceRequest_Resource()      {}
func (*ModifyResourceRequest_VpmemDisk) isModifyResourceRequest_Resource()     {}
func (*ModifyResourceRequest_NicConfig) isModifyResourceRequest_Resource()     {}
func (*ModifyResourceRequest_WindowsDevice) isModifyResourceRequest_Resource() {}

func (m *ModifyResourceRequest) GetResource() isModifyResourceRequest_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ModifyResourceRequest) GetScsiDisk() *SCSIDisk {
	if x, ok := m.GetResource().(*ModifyResourceRequest_ScsiDisk); ok {
		return x.ScsiDisk
	}
	return nil
}

func (m *ModifyResourceRequest) GetVpmemDisk() *VPMEMDisk {
	if x, ok := m.GetResource().(*ModifyResourceRequest_VpmemDisk); ok {
		return x.VpmemDisk
	}
	return nil
}

func (m *ModifyResourceRequest) GetNicConfig() *NICConfig {
	if x, ok := m.GetResource().(*ModifyResourceRequest_NicConfig); ok {
		return x.NicConfig
	}
	return nil
}

func (m *ModifyResourceRequest) GetWindowsDevice() *WindowsPCIDevice {
	if x, ok := m.GetResource().(*ModifyResourceRequest_WindowsDevice); ok {
		return x.WindowsDevice
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ModifyResourceRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ModifyResourceRequest_OneofMarshaler, _ModifyResourceRequest_OneofUnmarshaler, _ModifyResourceRequest_OneofSizer, []interface{}{
		(*ModifyResourceRequest_ScsiDisk)(nil),
		(*ModifyResourceRequest_VpmemDisk)(nil),
		(*ModifyResourceRequest_NicConfig)(nil),
		(*ModifyResourceRequest_WindowsDevice)(nil),
	}
}

func _ModifyResourceRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ModifyResourceRequest)
	// resource
	switch x := m.Resource.(type) {
	case *ModifyResourceRequest_ScsiDisk:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ScsiDisk); err != nil {
			return err
		}
	case *ModifyResourceRequest_VpmemDisk:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VpmemDisk); err != nil {
			return err
		}
	case *ModifyResourceRequest_NicConfig:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NicConfig); err != nil {
			return err
		}
	case *ModifyResourceRequest_WindowsDevice:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WindowsDevice); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ModifyResourceRequest.Resource has unexpected type %T", x)
	}
	return nil
}

func _ModifyResourceRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ModifyResourceRequest)
	switch tag {
	case 2: // resource.scsi_disk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SCSIDisk)
		err := b.DecodeMessage(msg)
		m.Resource = &ModifyResourceRequest_ScsiDisk{msg}
		return true, err
	case 3: // resource.vpmem_disk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VPMEMDisk)
		err := b.DecodeMessage(msg)
		m.Resource = &ModifyResourceRequest_VpmemDisk{msg}
		return true, err
	case 4: // resource.nic_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NICConfig)
		err := b.DecodeMessage(msg)
		m.Resource = &ModifyResourceRequest_NicConfig{msg}
		return true, err
	case 5: // resource.windows_device
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WindowsPCIDevice)
		err := b.DecodeMessage(msg)
		m.Resource = &ModifyResourceRequest_WindowsDevice{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ModifyResourceRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ModifyResourceRequest)
	// resource
	switch x := m.Resource.(type) {
	case *ModifyResourceRequest_ScsiDisk:
		s := proto.Size(x.ScsiDisk)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ModifyResourceRequest_VpmemDisk:
		s := proto.Size(x.VpmemDisk)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ModifyResourceRequest_NicConfig:
		s := proto.Size(x.NicConfig)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ModifyResourceRequest_WindowsDevice:
		s := proto.Size(x.WindowsDevice)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterEnum("vmservice.ModifyType", ModifyType_name, ModifyType_value)
	proto.RegisterEnum("vmservice.DiskType", DiskType_name, DiskType_value)
	proto.RegisterEnum("vmservice.MemoryConfig_BackingType", MemoryConfig_BackingType_name, MemoryConfig_BackingType_value)
	proto.RegisterEnum("vmservice.PropertiesVMRequest_PropertiesType", PropertiesVMRequest_PropertiesType_name, PropertiesVMRequest_PropertiesType_value)
	proto.RegisterEnum("vmservice.CapabilitiesVMResponse_Resource", CapabilitiesVMResponse_Resource_name, CapabilitiesVMResponse_Resource_value)
	proto.RegisterEnum("vmservice.CapabilitiesVMResponse_SupportedGuestOS", CapabilitiesVMResponse_SupportedGuestOS_name, CapabilitiesVMResponse_SupportedGuestOS_value)
	proto.RegisterType((*DirectBoot)(nil), "vmservice.DirectBoot")
	proto.RegisterType((*UEFI)(nil), "vmservice.UEFI")
	proto.RegisterType((*MemoryConfig)(nil), "vmservice.MemoryConfig")
	proto.RegisterType((*ProcessorConfig)(nil), "vmservice.ProcessorConfig")
	proto.RegisterType((*DevicesConfig)(nil), "vmservice.DevicesConfig")
	proto.RegisterType((*VMConfig)(nil), "vmservice.VMConfig")
	proto.RegisterMapType((map[string]string)(nil), "vmservice.VMConfig.ExtraDataEntry")
	proto.RegisterType((*SerialConfig)(nil), "vmservice.SerialConfig")
	proto.RegisterType((*SerialConfig_Config)(nil), "vmservice.SerialConfig.Config")
	proto.RegisterType((*CreateVMRequest)(nil), "vmservice.CreateVMRequest")
	proto.RegisterType((*InspectVMRequest)(nil), "vmservice.InspectVMRequest")
	proto.RegisterType((*InspectVMResponse)(nil), "vmservice.InspectVMResponse")
	proto.RegisterType((*MemoryStats)(nil), "vmservice.MemoryStats")
	proto.RegisterType((*ProcessorStats)(nil), "vmservice.ProcessorStats")
	proto.RegisterType((*PropertiesVMRequest)(nil), "vmservice.PropertiesVMRequest")
	proto.RegisterType((*PropertiesVMResponse)(nil), "vmservice.PropertiesVMResponse")
	proto.RegisterType((*CapabilitiesVMResponse)(nil), "vmservice.CapabilitiesVMResponse")
	proto.RegisterType((*CapabilitiesVMResponse_SupportedResource)(nil), "vmservice.CapabilitiesVMResponse.SupportedResource")
	proto.RegisterType((*HVSocketListen)(nil), "vmservice.HVSocketListen")
	proto.RegisterType((*VSockListen)(nil), "vmservice.VSockListen")
	proto.RegisterType((*VMSocketRequest)(nil), "vmservice.VMSocketRequest")
	proto.RegisterType((*SCSIDisk)(nil), "vmservice.SCSIDisk")
	proto.RegisterType((*VPMEMDisk)(nil), "vmservice.VPMEMDisk")
	proto.RegisterType((*ModifySCSIDiskRequest)(nil), "vmservice.ModifySCSIDiskRequest")
	proto.RegisterType((*ModifyVPMEMDiskRequest)(nil), "vmservice.ModifyVPMEMDiskRequest")
	proto.RegisterType((*NICConfig)(nil), "vmservice.NICConfig")
	proto.RegisterType((*ModifyNICRequest)(nil), "vmservice.ModifyNICRequest")
	proto.RegisterType((*WindowsPCIDevice)(nil), "vmservice.WindowsPCIDevice")
	proto.RegisterType((*ModifyPCIDeviceRequest)(nil), "vmservice.ModifyPCIDeviceRequest")
	proto.RegisterType((*ModifyResourceRequest)(nil), "vmservice.ModifyResourceRequest")
}

func init() {
	proto.RegisterFile("github.com/Microsoft/hcsshim/internal/vmservice/vmservice.proto", fileDescriptor_272f12cfdaa6c7c8)
}

var fileDescriptor_272f12cfdaa6c7c8 = []byte{
	// 2174 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0xcb, 0x73, 0x1b, 0xc7,
	0xd1, 0xc7, 0x12, 0x20, 0x08, 0x34, 0x1e, 0x5c, 0x0f, 0x65, 0x89, 0xa6, 0x5c, 0xa4, 0xbe, 0xd5,
	0x67, 0x4b, 0x96, 0x6d, 0xb0, 0x02, 0xc5, 0x29, 0x49, 0x51, 0xac, 0x10, 0x00, 0x65, 0x22, 0x22,
	0x24, 0x78, 0x41, 0x41, 0x51, 0x2e, 0xeb, 0xc5, 0xee, 0x10, 0x9c, 0xe2, 0xbe, 0xb4, 0x33, 0x20,
	0x8d, 0xaa, 0x1c, 0x52, 0x95, 0x43, 0x6e, 0xb9, 0xe5, 0x98, 0xca, 0x31, 0xe7, 0x5c, 0x52, 0x95,
	0x3f, 0x20, 0x55, 0x3e, 0xe6, 0x98, 0x4b, 0x54, 0x31, 0xef, 0x39, 0xe5, 0x9e, 0x4a, 0xcd, 0x63,
	0x81, 0x05, 0x08, 0x4a, 0xa1, 0x6e, 0x3b, 0x3d, 0xbf, 0x7e, 0x4c, 0x4f, 0x4f, 0x3f, 0x16, 0x1e,
	0x0d, 0x09, 0x3b, 0x1a, 0x0d, 0x6a, 0x4e, 0xe8, 0x6f, 0x77, 0x88, 0x13, 0x87, 0x34, 0x3c, 0x64,
	0xdb, 0x47, 0x0e, 0xa5, 0x47, 0xc4, 0xdf, 0x26, 0x01, 0xc3, 0x71, 0x60, 0x7b, 0xdb, 0x27, 0x3e,
	0xc5, 0xf1, 0x09, 0x71, 0xf0, 0xf4, 0xab, 0x16, 0xc5, 0x21, 0x0b, 0x51, 0x71, 0x42, 0xd8, 0xb8,
	0x3e, 0x0c, 0xc3, 0xa1, 0x87, 0xb7, 0xc5, 0xc6, 0x60, 0x74, 0xb8, 0x8d, 0xfd, 0x88, 0x8d, 0x25,
	0x6e, 0xe3, 0xc3, 0xf9, 0x4d, 0xca, 0xe2, 0x91, 0xc3, 0xe4, 0xae, 0x31, 0x02, 0x68, 0x91, 0x18,
	0x3b, 0xac, 0x11, 0x86, 0x0c, 0x6d, 0x41, 0xe9, 0x18, 0xc7, 0x01, 0xf6, 0xac, 0xc8, 0x66, 0x47,
	0xeb, 0xda, 0x0d, 0xed, 0x76, 0xd1, 0x04, 0x49, 0xea, 0xda, 0xec, 0x88, 0x03, 0x48, 0x40, 0x58,
	0xec, 0x4a, 0xc0, 0x92, 0x04, 0x48, 0x92, 0x00, 0x7c, 0x04, 0x55, 0x25, 0xc1, 0xf1, 0x5d, 0x8f,
	0x04, 0x78, 0x3d, 0x2b, 0x30, 0x15, 0x49, 0x6d, 0x4a, 0xa2, 0xf1, 0x0a, 0x72, 0xcf, 0x77, 0x1f,
	0xb7, 0xd1, 0x4d, 0xa8, 0x1c, 0x92, 0xd8, 0x3f, 0xb5, 0x63, 0x9c, 0x56, 0x59, 0x4e, 0x88, 0x89,
	0x52, 0x17, 0xf3, 0x83, 0xce, 0x28, 0x95, 0x24, 0x01, 0xb8, 0x09, 0x95, 0x30, 0x62, 0x24, 0x0c,
	0x6c, 0xcf, 0x72, 0x6d, 0x66, 0x2b, 0x9d, 0xe5, 0x84, 0xd8, 0xb2, 0x99, 0x6d, 0xfc, 0x71, 0x09,
	0xca, 0x1d, 0xec, 0x87, 0xf1, 0xb8, 0x19, 0x06, 0x87, 0x64, 0x88, 0xae, 0x43, 0xd1, 0x17, 0x6b,
	0xcb, 0x1f, 0x08, 0xbd, 0x39, 0xb3, 0x20, 0x09, 0x9d, 0x01, 0x7a, 0x0c, 0xe5, 0x81, 0xed, 0x1c,
	0x93, 0x60, 0x68, 0xb1, 0x71, 0x84, 0x85, 0xd2, 0x6a, 0xfd, 0x66, 0x6d, 0x7a, 0x0b, 0x69, 0x59,
	0xb5, 0x86, 0xc4, 0x1e, 0x8c, 0x23, 0x6c, 0x96, 0x06, 0xd3, 0x05, 0xba, 0x03, 0xc8, 0x0b, 0x4f,
	0x2d, 0xdf, 0x27, 0xa1, 0x35, 0xb4, 0x23, 0x8b, 0x04, 0x5c, 0x5b, 0x56, 0x68, 0xab, 0x7a, 0xe1,
	0x69, 0xc7, 0x27, 0xe1, 0x57, 0x76, 0xd4, 0x0e, 0x3a, 0x03, 0x54, 0x83, 0x2b, 0x47, 0x64, 0x78,
	0x24, 0xc1, 0x03, 0x9b, 0x62, 0x85, 0xce, 0x09, 0xb4, 0xce, 0xf7, 0x38, 0xbc, 0x61, 0x53, 0x2c,
	0xf0, 0x9f, 0xc1, 0xda, 0x14, 0x3f, 0x15, 0xbe, 0x2c, 0xe0, 0xab, 0x09, 0x5c, 0x49, 0x37, 0x6e,
	0x43, 0x29, 0x65, 0x25, 0x2a, 0x43, 0xa1, 0xbb, 0xf7, 0xb2, 0xd7, 0x6e, 0xee, 0xec, 0xeb, 0x19,
	0x54, 0x82, 0x95, 0x7e, 0xdb, 0x3c, 0x78, 0xbe, 0xb3, 0xaf, 0x6b, 0xc6, 0x03, 0x58, 0xed, 0xc6,
	0xa1, 0x83, 0x29, 0x0d, 0x63, 0xe5, 0xab, 0x5b, 0xb0, 0x1a, 0x25, 0x24, 0xcb, 0x09, 0x47, 0x01,
	0x13, 0x1e, 0xab, 0x98, 0xd5, 0x68, 0x8a, 0x1c, 0x05, 0xcc, 0xf8, 0xb7, 0x06, 0x95, 0x96, 0xb8,
	0x19, 0xaa, 0x58, 0xeb, 0x00, 0xd4, 0xa1, 0xc4, 0x72, 0x09, 0x3d, 0xa6, 0xeb, 0xda, 0x8d, 0xec,
	0xed, 0x52, 0x7d, 0x2d, 0xe5, 0xc7, 0x5e, 0xb3, 0xd7, 0x6e, 0x11, 0x7a, 0x6c, 0x16, 0x39, 0x8c,
	0x7f, 0x51, 0xf4, 0x05, 0x94, 0x4e, 0x22, 0x1f, 0xfb, 0x8a, 0x69, 0x49, 0x30, 0x5d, 0x49, 0x31,
	0xf5, 0xbb, 0x9d, 0xdd, 0x8e, 0xe0, 0x02, 0x01, 0x94, 0x6c, 0x77, 0x01, 0x02, 0xe2, 0x58, 0x8e,
	0x50, 0xbc, 0x9e, 0x3d, 0xc7, 0xf5, 0xb4, 0xdd, 0x94, 0x46, 0x99, 0xc5, 0x80, 0x38, 0xca, 0xbe,
	0x06, 0x54, 0x4f, 0x49, 0xe0, 0x86, 0xa7, 0xd4, 0x92, 0x21, 0xb5, 0x9e, 0x13, 0x8c, 0xd7, 0x53,
	0x8c, 0x2f, 0x24, 0xa0, 0xdb, 0x6c, 0xcb, 0xb3, 0x99, 0x15, 0xc5, 0x22, 0x97, 0xc6, 0x7f, 0xb2,
	0x50, 0xe8, 0x77, 0x94, 0xc0, 0x87, 0x50, 0x51, 0x71, 0xa5, 0x0c, 0xe1, 0x9e, 0x2a, 0xd5, 0xaf,
	0x5d, 0x10, 0x3b, 0x66, 0xd9, 0x4f, 0x47, 0xe5, 0x2e, 0xe8, 0x69, 0x4f, 0x0b, 0x01, 0x4b, 0x42,
	0xc0, 0x46, 0x4a, 0xc0, 0xdc, 0xfd, 0x98, 0xab, 0xd1, 0xdc, 0x85, 0x3d, 0x82, 0xaa, 0x3c, 0x0d,
	0x9d, 0xba, 0x83, 0x0b, 0x59, 0x4f, 0x09, 0x99, 0xb9, 0x27, 0xb3, 0xe2, 0xce, 0x5c, 0xdb, 0x43,
	0xa8, 0x50, 0x1c, 0x13, 0xdb, 0x4b, 0xf8, 0x73, 0xe7, 0x4e, 0xd1, 0x13, 0xfb, 0xc9, 0x29, 0x68,
	0x6a, 0x85, 0xee, 0x41, 0xc9, 0x15, 0x69, 0xc5, 0x1a, 0x84, 0x21, 0x13, 0x21, 0x59, 0xaa, 0xbf,
	0x9f, 0xd6, 0x3d, 0x49, 0x3a, 0x7b, 0x19, 0x13, 0xdc, 0x69, 0x0a, 0xfa, 0x08, 0x72, 0x23, 0x7c,
	0x48, 0xd6, 0xf3, 0x82, 0x65, 0x35, 0xc5, 0xc2, 0x13, 0xc6, 0x5e, 0xc6, 0x14, 0xdb, 0x68, 0x07,
	0x00, 0x7f, 0xcb, 0x62, 0x5b, 0xbe, 0xf7, 0x15, 0x71, 0x63, 0x46, 0x3a, 0x40, 0xd4, 0x6d, 0xd4,
	0x76, 0x39, 0x8a, 0x27, 0x80, 0xdd, 0x80, 0xc5, 0x63, 0xb3, 0x88, 0x93, 0xf5, 0xc6, 0x43, 0xa8,
	0xce, 0x6e, 0x22, 0x1d, 0xb2, 0xc7, 0x78, 0xac, 0x72, 0x10, 0xff, 0x44, 0x57, 0x60, 0xf9, 0xc4,
	0xf6, 0x46, 0x58, 0x25, 0x1d, 0xb9, 0x78, 0xb0, 0x74, 0x4f, 0x6b, 0x94, 0x01, 0xb8, 0xbd, 0x52,
	0x8b, 0xf1, 0x6b, 0x0d, 0xca, 0x69, 0x77, 0xa0, 0x1f, 0xc2, 0x72, 0x14, 0xc6, 0x8c, 0xaa, 0x28,
	0xdc, 0xbc, 0xc0, 0x6d, 0x35, 0xe5, 0x3d, 0x09, 0xde, 0xf8, 0x09, 0xe4, 0x15, 0x3f, 0x82, 0x1c,
	0x27, 0xa9, 0x57, 0x26, 0xbe, 0x79, 0x1e, 0xa4, 0xa1, 0x73, 0x8c, 0xd9, 0x4c, 0x1e, 0x94, 0x24,
	0x9e, 0x07, 0x8d, 0x6f, 0x60, 0xb5, 0x19, 0x63, 0x9b, 0xe1, 0x7e, 0xc7, 0xc4, 0xaf, 0x46, 0x98,
	0x32, 0xf4, 0x29, 0xe4, 0x67, 0xa2, 0x70, 0x6d, 0x81, 0x8f, 0x4c, 0x05, 0x41, 0x37, 0x20, 0xef,
	0x85, 0x43, 0x8b, 0xb8, 0x52, 0x76, 0xa3, 0x78, 0xf6, 0x7a, 0x6b, 0x79, 0x3f, 0x1c, 0xb6, 0x5b,
	0xe6, 0xb2, 0x17, 0x0e, 0xdb, 0xae, 0xf1, 0x35, 0xe8, 0xed, 0x80, 0x46, 0xd8, 0x61, 0x53, 0x15,
	0x57, 0x60, 0xf9, 0xd5, 0x08, 0xc7, 0x89, 0xdf, 0xe4, 0x82, 0x67, 0x8c, 0x18, 0x3b, 0xa3, 0x98,
	0x92, 0x30, 0xb0, 0x3c, 0xe2, 0x13, 0x26, 0x84, 0x56, 0xcc, 0xea, 0x84, 0xbc, 0xcf, 0xa9, 0x46,
	0x13, 0xde, 0x4b, 0x89, 0xa4, 0x51, 0x18, 0x50, 0x8c, 0x6a, 0x90, 0x8f, 0x31, 0x1d, 0x79, 0x4c,
	0x99, 0x7d, 0xb5, 0x26, 0xab, 0x58, 0x2d, 0xa9, 0x62, 0xb5, 0x3e, 0xbf, 0x09, 0x53, 0xa1, 0x8c,
	0x3f, 0x69, 0x50, 0x92, 0x8f, 0xaa, 0xc7, 0x6c, 0x46, 0xd1, 0x6d, 0x58, 0x7d, 0x11, 0xc6, 0x3c,
	0xd9, 0xf5, 0x30, 0x6b, 0x8c, 0x19, 0xa6, 0x2a, 0xc3, 0xcf, 0x93, 0x39, 0x72, 0xe7, 0xc4, 0x26,
	0x9e, 0x3d, 0xf0, 0xb0, 0x94, 0x20, 0xec, 0xcc, 0x99, 0xf3, 0x64, 0xf4, 0x31, 0x54, 0x4d, 0xcc,
	0x7d, 0x87, 0x5d, 0x05, 0x54, 0x69, 0x7c, 0x96, 0xca, 0x71, 0x3b, 0x94, 0x92, 0x61, 0x30, 0xc1,
	0xc9, 0x04, 0x3e, 0x47, 0x35, 0x7e, 0x09, 0xd5, 0xc9, 0x33, 0x96, 0x56, 0x1b, 0x50, 0x3e, 0x08,
	0x99, 0xed, 0x99, 0xa3, 0x80, 0x11, 0x1f, 0x2b, 0x93, 0x67, 0x68, 0xe8, 0x06, 0x94, 0xd4, 0xe7,
	0x73, 0x8a, 0x63, 0x65, 0x6b, 0x9a, 0x84, 0xfe, 0x1f, 0x2a, 0x6a, 0xf9, 0x44, 0xd4, 0x5c, 0x65,
	0xe6, 0x2c, 0xd1, 0xf8, 0x8d, 0x06, 0x6b, 0xdd, 0x38, 0x8c, 0x70, 0xcc, 0x08, 0xa6, 0xd3, 0xdb,
	0x6c, 0xc2, 0x32, 0x2f, 0x78, 0x32, 0x53, 0x57, 0xeb, 0x9f, 0xcf, 0x26, 0x9d, 0x79, 0x78, 0x8a,
	0x26, 0x6a, 0x9f, 0xe4, 0x35, 0x3e, 0x15, 0x47, 0x4b, 0x6d, 0x20, 0x80, 0xbc, 0x3c, 0xb6, 0x9e,
	0x41, 0x15, 0x28, 0x4e, 0x0e, 0xae, 0x6b, 0xc6, 0xef, 0x34, 0xb8, 0x32, 0x2b, 0x5a, 0x05, 0xc1,
	0x7d, 0x50, 0xa9, 0xd1, 0xa2, 0xdc, 0x3d, 0x93, 0x50, 0x98, 0xcf, 0xa3, 0xc2, 0x79, 0x66, 0xc9,
	0x4f, 0xdd, 0x7f, 0x23, 0x5d, 0xaf, 0x24, 0xb7, 0x4c, 0xa2, 0x1f, 0x2c, 0x4a, 0xa2, 0x52, 0xc0,
	0xb4, 0x94, 0x89, 0xb5, 0xf1, 0xaf, 0x2c, 0x5c, 0x6d, 0xda, 0x91, 0x3d, 0x20, 0x1e, 0x99, 0xb3,
	0xcc, 0x85, 0x35, 0x3a, 0x8a, 0xf8, 0xa3, 0xc4, 0xae, 0x15, 0x63, 0x1a, 0x8e, 0x62, 0x07, 0x27,
	0xc5, 0xed, 0x6e, 0x4a, 0xc5, 0x62, 0xfe, 0x5a, 0x2f, 0x61, 0x36, 0x15, 0xaf, 0x89, 0xe8, 0x3c,
	0x89, 0xa2, 0x6f, 0x60, 0x4a, 0xb5, 0x86, 0xdc, 0xdd, 0x56, 0x28, 0x8b, 0x61, 0xb5, 0x5e, 0xbf,
	0x84, 0x92, 0xaf, 0x38, 0xeb, 0xb3, 0x9e, 0xa9, 0xd3, 0x59, 0x0a, 0xdd, 0xf8, 0xbd, 0x06, 0xef,
	0x9d, 0xb3, 0x85, 0xa7, 0xc1, 0x1d, 0xd7, 0x15, 0xee, 0x2e, 0x98, 0xfc, 0x13, 0x5d, 0x85, 0xbc,
	0x89, 0xfd, 0xf0, 0x44, 0xe6, 0xc1, 0x82, 0xa9, 0x56, 0x9c, 0xfe, 0x3c, 0x72, 0x6d, 0x26, 0xbb,
	0xbc, 0x82, 0xa9, 0x56, 0xe8, 0x31, 0x14, 0x12, 0xaf, 0x88, 0xe0, 0xaf, 0xd6, 0xef, 0xbc, 0xdd,
	0xde, 0x89, 0x2f, 0x26, 0xbc, 0xc6, 0x23, 0x28, 0x4c, 0xac, 0x2a, 0xc2, 0x72, 0x9f, 0x97, 0x7a,
	0x3d, 0x83, 0x0a, 0x90, 0xeb, 0x39, 0x94, 0xe8, 0x1a, 0xff, 0xea, 0x47, 0x0e, 0xd1, 0x97, 0xf8,
	0x76, 0xd7, 0xb3, 0x83, 0xfb, 0x7a, 0x56, 0x20, 0x3b, 0x4f, 0x89, 0xa3, 0xe7, 0x8c, 0x3b, 0xa0,
	0xcf, 0xbb, 0x81, 0xf7, 0x3a, 0xaa, 0x9e, 0xeb, 0x19, 0x8e, 0xdd, 0x27, 0xc1, 0xe8, 0x5b, 0x5d,
	0x33, 0x1c, 0xa8, 0xee, 0xf5, 0x7b, 0x22, 0x9b, 0xee, 0x13, 0xca, 0x70, 0x80, 0x3e, 0x03, 0x50,
	0x36, 0xf3, 0x9c, 0x28, 0xd2, 0x5b, 0xa3, 0x72, 0xf6, 0x7a, 0xab, 0xd8, 0x93, 0xd4, 0x76, 0xcb,
	0x2c, 0x2a, 0x40, 0xdb, 0xe5, 0x5d, 0xa8, 0x27, 0xf8, 0x70, 0x9c, 0x4e, 0xd0, 0xe5, 0x84, 0x28,
	0x52, 0xf4, 0x63, 0x28, 0x09, 0x1d, 0x4a, 0xc3, 0xa2, 0x34, 0xff, 0x3f, 0xc9, 0xf9, 0xab, 0x06,
	0xab, 0xfd, 0x8e, 0xb4, 0x36, 0x79, 0xba, 0x9f, 0x40, 0x4e, 0xf4, 0xaa, 0x9a, 0xf0, 0x78, 0xba,
	0xda, 0x76, 0x42, 0x97, 0x1c, 0x8e, 0xc5, 0x0b, 0x15, 0x10, 0xf4, 0x53, 0xa8, 0x1c, 0x9d, 0xa8,
	0x62, 0xc2, 0xe5, 0x2e, 0x78, 0x1d, 0xb3, 0xbe, 0xd8, 0xcb, 0x98, 0xe5, 0x84, 0x83, 0x53, 0xd0,
	0x8f, 0xa1, 0x2c, 0x96, 0x96, 0x34, 0x4b, 0xb5, 0x17, 0xe9, 0xc7, 0x99, 0x3a, 0xe7, 0x5e, 0xc6,
	0x2c, 0x09, 0xb4, 0x5c, 0x36, 0x0a, 0x49, 0x9d, 0x33, 0xfe, 0xa0, 0x41, 0x21, 0xe9, 0x00, 0xd1,
	0x26, 0x80, 0x13, 0x06, 0x2c, 0x0e, 0x3d, 0x0f, 0xc7, 0xca, 0x27, 0x29, 0x0a, 0x0f, 0x4c, 0x6f,
	0x14, 0xa8, 0x3a, 0xc2, 0x3f, 0x79, 0x0f, 0x7f, 0x14, 0x52, 0x55, 0x10, 0x65, 0xd7, 0x5f, 0xe0,
	0x04, 0x31, 0x16, 0xdc, 0x52, 0xfe, 0x90, 0x11, 0xb8, 0x36, 0xd3, 0x7d, 0xd0, 0xe3, 0x94, 0x37,
	0xae, 0x43, 0x31, 0xc6, 0xb6, 0x6b, 0x85, 0x81, 0x37, 0x16, 0xbd, 0x4a, 0x81, 0xc7, 0xa0, 0xed,
	0x3e, 0x0b, 0xbc, 0xb1, 0x11, 0x40, 0x71, 0xd2, 0x6d, 0xce, 0xea, 0xd3, 0x2e, 0xd0, 0xb7, 0x74,
	0x29, 0x7d, 0xd9, 0x39, 0x7d, 0xc7, 0xf0, 0xbe, 0xbc, 0xae, 0x49, 0x63, 0x7c, 0xf9, 0xeb, 0xbd,
	0x05, 0x39, 0xde, 0x39, 0xab, 0x5b, 0x5d, 0xd8, 0x6d, 0x0b, 0x80, 0xe1, 0xc3, 0x55, 0xc9, 0x3c,
	0x6d, 0xa8, 0x2f, 0xaf, 0xed, 0xf6, 0x8c, 0xb6, 0xc5, 0x6d, 0xba, 0x54, 0xf7, 0x17, 0x0d, 0x8a,
	0x93, 0x26, 0x9c, 0xb7, 0x1b, 0xbc, 0x5d, 0x9f, 0x3c, 0x2d, 0xd1, 0x6e, 0x3c, 0x25, 0x0e, 0x6f,
	0x37, 0x02, 0xe2, 0x88, 0x27, 0xb5, 0xc2, 0x9f, 0xc4, 0xb4, 0x23, 0x81, 0xb3, 0xd7, 0x5b, 0xf9,
	0x6e, 0x18, 0xb3, 0x76, 0xcb, 0xcc, 0xf3, 0xad, 0xb6, 0xcb, 0xdb, 0x22, 0xdf, 0x76, 0x2c, 0xdb,
	0x75, 0x63, 0x4c, 0xa9, 0x8a, 0x02, 0xf0, 0x6d, 0x67, 0x47, 0x52, 0xd0, 0x27, 0x50, 0xa4, 0xa7,
	0x84, 0x39, 0x47, 0x5c, 0x4e, 0x4e, 0xc8, 0x29, 0x9f, 0xbd, 0xde, 0x2a, 0xf4, 0x04, 0xb1, 0xdd,
	0x32, 0x0b, 0x72, 0xbb, 0xed, 0xa2, 0x0f, 0xa0, 0xc0, 0x4d, 0x0a, 0x6c, 0x1f, 0x8b, 0x40, 0x28,
	0x9a, 0x2b, 0x01, 0x71, 0x9e, 0xda, 0x3e, 0x36, 0x30, 0xe8, 0xf2, 0xe4, 0x4f, 0xdb, 0xcd, 0x77,
	0x70, 0xd2, 0xc7, 0x90, 0x0d, 0x88, 0xb3, 0xc0, 0x47, 0xd3, 0xa1, 0x84, 0x03, 0x8c, 0x26, 0xe8,
	0xf3, 0xd3, 0x06, 0xda, 0xe6, 0x53, 0x37, 0x65, 0x76, 0x90, 0x4e, 0x44, 0xd5, 0xb3, 0xd7, 0x5b,
	0xd0, 0x56, 0xe4, 0x76, 0x8b, 0x4f, 0xe1, 0xea, 0xdb, 0x35, 0x7e, 0xab, 0x25, 0xf7, 0x3a, 0x1d,
	0x59, 0x2e, 0x6f, 0x72, 0x1b, 0x50, 0x32, 0x19, 0x45, 0x0e, 0x49, 0xa6, 0x23, 0x79, 0x82, 0x37,
	0x4e, 0x47, 0xba, 0x62, 0xeb, 0x3a, 0x44, 0x0d, 0x48, 0x7f, 0x5e, 0x4a, 0xa2, 0x7a, 0x92, 0xe5,
	0x2f, 0x6f, 0x4f, 0x1d, 0x8a, 0x93, 0x49, 0xf2, 0x0d, 0xa1, 0xbd, 0x97, 0x31, 0x0b, 0xc9, 0x28,
	0x89, 0xbe, 0x00, 0x98, 0x4e, 0x92, 0x2a, 0x49, 0x2d, 0x8c, 0xd0, 0xbd, 0x8c, 0x59, 0x9c, 0x8c,
	0x92, 0x9c, 0x2d, 0x35, 0x49, 0xe6, 0x2e, 0xbe, 0x34, 0xce, 0x36, 0x9d, 0x25, 0x5b, 0xe7, 0x66,
	0xc9, 0xe5, 0xb7, 0x7a, 0x6b, 0x2f, 0x33, 0x37, 0x4d, 0x36, 0x60, 0x5a, 0x3d, 0xef, 0x7c, 0x0e,
	0x30, 0xf5, 0x03, 0x5a, 0x81, 0xec, 0x4e, 0xab, 0xa5, 0x67, 0x78, 0x3b, 0x65, 0xee, 0x76, 0x9e,
	0xf5, 0x77, 0x75, 0x8d, 0x7f, 0x3f, 0xef, 0xb6, 0x76, 0x0e, 0x76, 0xf5, 0xa5, 0x3b, 0x2f, 0xa1,
	0x90, 0xe4, 0x1a, 0x74, 0x0d, 0xd6, 0xb8, 0x4b, 0xac, 0x56, 0xbb, 0xf7, 0xc4, 0x3a, 0x78, 0xd9,
	0xdd, 0xb5, 0xfa, 0x7b, 0xad, 0x1f, 0xe8, 0x99, 0xc5, 0x1b, 0x3f, 0xd7, 0x35, 0x74, 0x1d, 0xae,
	0xcd, 0x6d, 0x4c, 0x7e, 0x11, 0x2c, 0xd5, 0xff, 0xb1, 0x0c, 0x4b, 0xfd, 0x0e, 0xfa, 0x12, 0x0a,
	0xc9, 0x8c, 0x81, 0xd2, 0x13, 0xe9, 0xdc, 0xe0, 0xb1, 0x71, 0xbe, 0x63, 0xdf, 0xf5, 0x23, 0x36,
	0x46, 0x0f, 0x01, 0x0e, 0xb0, 0x1d, 0xbb, 0xe1, 0x69, 0xd0, 0xef, 0xa0, 0x0b, 0x50, 0x17, 0x72,
	0xdf, 0x87, 0x95, 0xae, 0x3d, 0xa2, 0xf8, 0x1d, 0x58, 0x1f, 0x88, 0x5e, 0x62, 0xe4, 0xbf, 0x0b,
	0xef, 0x3d, 0xc8, 0xbf, 0xb0, 0x09, 0x7b, 0x07, 0xce, 0xc7, 0x50, 0x9c, 0x4c, 0x37, 0x28, 0x1d,
	0x06, 0xf3, 0x63, 0xd4, 0xc6, 0x87, 0x8b, 0x37, 0x55, 0xc7, 0xf9, 0x04, 0xaa, 0xb3, 0x6d, 0xd3,
	0x85, 0x96, 0xfc, 0xdf, 0x5b, 0x3b, 0x2d, 0xf4, 0x0c, 0xca, 0xe9, 0x86, 0x1b, 0x6d, 0xbe, 0xb9,
	0xc9, 0xdf, 0xd8, 0xba, 0x70, 0x5f, 0x09, 0xfc, 0x19, 0x54, 0x67, 0x5f, 0x37, 0xba, 0x71, 0xee,
	0x21, 0xcf, 0x3d, 0xfc, 0x0b, 0x3d, 0xf6, 0x25, 0x14, 0x92, 0xc6, 0x66, 0x26, 0xc0, 0xe6, 0xba,
	0x9d, 0x0b, 0xf9, 0x7f, 0x04, 0xb9, 0xaf, 0x47, 0x84, 0x5d, 0xf6, 0xa6, 0x1a, 0x37, 0xbf, 0xfb,
	0x7e, 0x33, 0xf3, 0xf7, 0xef, 0x37, 0x33, 0xbf, 0x3a, 0xdb, 0xd4, 0xbe, 0x3b, 0xdb, 0xd4, 0xfe,
	0x76, 0xb6, 0xa9, 0xfd, 0xf3, 0x6c, 0x53, 0xfb, 0xc5, 0xf4, 0x4f, 0xeb, 0x20, 0x2f, 0x98, 0xee,
	0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0xc7, 0xac, 0x4b, 0x4b, 0xbe, 0x15, 0x00, 0x00,
}

func (m *DirectBoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectBoot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KernelPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.KernelPath)))
		i += copy(dAtA[i:], m.KernelPath)
	}
	if len(m.InitrdPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.InitrdPath)))
		i += copy(dAtA[i:], m.InitrdPath)
	}
	if len(m.KernelCmdline) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.KernelCmdline)))
		i += copy(dAtA[i:], m.KernelCmdline)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UEFI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEFI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FirmwarePath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.FirmwarePath)))
		i += copy(dAtA[i:], m.FirmwarePath)
	}
	if len(m.DevicePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.DevicePath)))
		i += copy(dAtA[i:], m.DevicePath)
	}
	if len(m.OptionalData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.OptionalData)))
		i += copy(dAtA[i:], m.OptionalData)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MemoryConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemoryMb != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.MemoryMb))
	}
	if m.BackingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.BackingType))
	}
	if m.LowMmioGapInMb != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.LowMmioGapInMb))
	}
	if m.HighMmioBaseInMb != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.HighMmioBaseInMb))
	}
	if m.HighMmioGapInMb != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.HighMmioGapInMb))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProcessorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProcessorCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.ProcessorCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DevicesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DevicesConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ScsiDisks) > 0 {
		for _, msg := range m.ScsiDisks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVmservice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.VpmemDisks) > 0 {
		for _, msg := range m.VpmemDisks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintVmservice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NicConfig) > 0 {
		for _, msg := range m.NicConfig {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVmservice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WindowsDevice) > 0 {
		for _, msg := range m.WindowsDevice {
			dAtA[i] = 0x22
			i++
			i = encodeVarintVmservice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VMConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemoryConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.MemoryConfig.Size()))
		n1, err := m.MemoryConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ProcessorConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.ProcessorConfig.Size()))
		n2, err := m.ProcessorConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.DevicesConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.DevicesConfig.Size()))
		n3, err := m.DevicesConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.SerialConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.SerialConfig.Size()))
		n4, err := m.SerialConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.BootConfig != nil {
		nn5, err := m.BootConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if len(m.ExtraData) > 0 {
		for k, _ := range m.ExtraData {
			dAtA[i] = 0x3a
			i++
			v := m.ExtraData[k]
			mapSize := 1 + len(k) + sovVmservice(uint64(len(k))) + 1 + len(v) + sovVmservice(uint64(len(v)))
			i = encodeVarintVmservice(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVmservice(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintVmservice(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VMConfig_DirectBoot) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DirectBoot != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.DirectBoot.Size()))
		n6, err := m.DirectBoot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *VMConfig_Uefi) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Uefi != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Uefi.Size()))
		n7, err := m.Uefi.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *SerialConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SerialConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVmservice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SerialConfig_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SerialConfig_Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Port))
	}
	if len(m.SocketPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.SocketPath)))
		i += copy(dAtA[i:], m.SocketPath)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateVMRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVMRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Config.Size()))
		n8, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.LogID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.LogID)))
		i += copy(dAtA[i:], m.LogID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InspectVMRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectVMRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	if m.RecursionLimit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.RecursionLimit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InspectVMResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectVMResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Result.Size()))
		n9, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MemoryStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WorkingSetBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.WorkingSetBytes))
	}
	if m.AvailableMemory != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.AvailableMemory))
	}
	if m.ReservedMemory != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.ReservedMemory))
	}
	if m.AssignedMemory != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.AssignedMemory))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProcessorStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalRuntime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.TotalRuntime))
	}
	if m.RuntimeUser != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.RuntimeUser))
	}
	if m.RuntimeKernel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.RuntimeKernel))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PropertiesVMRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertiesVMRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		dAtA11 := make([]byte, len(m.Types)*10)
		var j10 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PropertiesVMResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertiesVMResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemoryStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.MemoryStats.Size()))
		n12, err := m.MemoryStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.ProcessorStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.ProcessorStats.Size()))
		n13, err := m.ProcessorStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CapabilitiesVMResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapabilitiesVMResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SupportedResources) > 0 {
		for _, msg := range m.SupportedResources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVmservice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SupportedGuestOs) > 0 {
		dAtA15 := make([]byte, len(m.SupportedGuestOs)*10)
		var j14 int
		for _, num := range m.SupportedGuestOs {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CapabilitiesVMResponse_SupportedResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapabilitiesVMResponse_SupportedResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Add {
		dAtA[i] = 0x8
		i++
		if m.Add {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Remove {
		dAtA[i] = 0x10
		i++
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Update {
		dAtA[i] = 0x18
		i++
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Resource != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Resource))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HVSocketListen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HVSocketListen) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.ServiceID)))
		i += copy(dAtA[i:], m.ServiceID)
	}
	if len(m.ListenerPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.ListenerPath)))
		i += copy(dAtA[i:], m.ListenerPath)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VSockListen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VSockListen) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Port))
	}
	if len(m.ListenerPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.ListenerPath)))
		i += copy(dAtA[i:], m.ListenerPath)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VMSocketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMSocketRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Type))
	}
	if m.Config != nil {
		nn16, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VMSocketRequest_HvsocketList) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HvsocketList != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.HvsocketList.Size()))
		n17, err := m.HvsocketList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *VMSocketRequest_VsockListen) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VsockListen != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.VsockListen.Size()))
		n18, err := m.VsockListen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *SCSIDisk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCSIDisk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Controller != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Controller))
	}
	if m.Lun != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Lun))
	}
	if len(m.HostPath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.HostPath)))
		i += copy(dAtA[i:], m.HostPath)
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Type))
	}
	if m.ReadOnly {
		dAtA[i] = 0x28
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VPMEMDisk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VPMEMDisk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.HostPath)))
		i += copy(dAtA[i:], m.HostPath)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Type))
	}
	if m.ReadOnly {
		dAtA[i] = 0x18
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModifySCSIDiskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifySCSIDiskRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Type))
	}
	if m.Disk != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Disk.Size()))
		n19, err := m.Disk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModifyVPMEMDiskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyVPMEMDiskRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Type))
	}
	if m.Disk != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Disk.Size()))
		n20, err := m.Disk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NICConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NICConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NicID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.NicID)))
		i += copy(dAtA[i:], m.NicID)
	}
	if len(m.PortID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.PortID)))
		i += copy(dAtA[i:], m.PortID)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.SwitchID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.SwitchID)))
		i += copy(dAtA[i:], m.SwitchID)
	}
	if len(m.NicName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.NicName)))
		i += copy(dAtA[i:], m.NicName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModifyNICRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyNICRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Type))
	}
	if m.Nic != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Nic.Size()))
		n21, err := m.Nic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WindowsPCIDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsPCIDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InstanceID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(len(m.InstanceID)))
		i += copy(dAtA[i:], m.InstanceID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModifyPCIDeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyPCIDeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Type))
	}
	if m.WindowsPciDevice != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.WindowsPciDevice.Size()))
		n22, err := m.WindowsPciDevice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModifyResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.Type))
	}
	if m.Resource != nil {
		nn23, err := m.Resource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModifyResourceRequest_ScsiDisk) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ScsiDisk != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.ScsiDisk.Size()))
		n24, err := m.ScsiDisk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *ModifyResourceRequest_VpmemDisk) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VpmemDisk != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.VpmemDisk.Size()))
		n25, err := m.VpmemDisk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *ModifyResourceRequest_NicConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NicConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.NicConfig.Size()))
		n26, err := m.NicConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *ModifyResourceRequest_WindowsDevice) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WindowsDevice != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVmservice(dAtA, i, uint64(m.WindowsDevice.Size()))
		n27, err := m.WindowsDevice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func encodeVarintVmservice(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DirectBoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KernelPath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.InitrdPath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.KernelCmdline)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UEFI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FirmwarePath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.DevicePath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.OptionalData)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoryMb != 0 {
		n += 1 + sovVmservice(uint64(m.MemoryMb))
	}
	if m.BackingType != 0 {
		n += 1 + sovVmservice(uint64(m.BackingType))
	}
	if m.LowMmioGapInMb != 0 {
		n += 1 + sovVmservice(uint64(m.LowMmioGapInMb))
	}
	if m.HighMmioBaseInMb != 0 {
		n += 1 + sovVmservice(uint64(m.HighMmioBaseInMb))
	}
	if m.HighMmioGapInMb != 0 {
		n += 1 + sovVmservice(uint64(m.HighMmioGapInMb))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessorCount != 0 {
		n += 1 + sovVmservice(uint64(m.ProcessorCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DevicesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ScsiDisks) > 0 {
		for _, e := range m.ScsiDisks {
			l = e.Size()
			n += 1 + l + sovVmservice(uint64(l))
		}
	}
	if len(m.VpmemDisks) > 0 {
		for _, e := range m.VpmemDisks {
			l = e.Size()
			n += 1 + l + sovVmservice(uint64(l))
		}
	}
	if len(m.NicConfig) > 0 {
		for _, e := range m.NicConfig {
			l = e.Size()
			n += 1 + l + sovVmservice(uint64(l))
		}
	}
	if len(m.WindowsDevice) > 0 {
		for _, e := range m.WindowsDevice {
			l = e.Size()
			n += 1 + l + sovVmservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoryConfig != nil {
		l = m.MemoryConfig.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.ProcessorConfig != nil {
		l = m.ProcessorConfig.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.DevicesConfig != nil {
		l = m.DevicesConfig.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.SerialConfig != nil {
		l = m.SerialConfig.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.BootConfig != nil {
		n += m.BootConfig.Size()
	}
	if len(m.ExtraData) > 0 {
		for k, v := range m.ExtraData {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVmservice(uint64(len(k))) + 1 + len(v) + sovVmservice(uint64(len(v)))
			n += mapEntrySize + 1 + sovVmservice(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMConfig_DirectBoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DirectBoot != nil {
		l = m.DirectBoot.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	return n
}
func (m *VMConfig_Uefi) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uefi != nil {
		l = m.Uefi.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	return n
}
func (m *SerialConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovVmservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SerialConfig_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovVmservice(uint64(m.Port))
	}
	l = len(m.SocketPath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateVMRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.LogID)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectVMRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.RecursionLimit != 0 {
		n += 1 + sovVmservice(uint64(m.RecursionLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectVMResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkingSetBytes != 0 {
		n += 1 + sovVmservice(uint64(m.WorkingSetBytes))
	}
	if m.AvailableMemory != 0 {
		n += 1 + sovVmservice(uint64(m.AvailableMemory))
	}
	if m.ReservedMemory != 0 {
		n += 1 + sovVmservice(uint64(m.ReservedMemory))
	}
	if m.AssignedMemory != 0 {
		n += 1 + sovVmservice(uint64(m.AssignedMemory))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessorStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalRuntime != 0 {
		n += 1 + sovVmservice(uint64(m.TotalRuntime))
	}
	if m.RuntimeUser != 0 {
		n += 1 + sovVmservice(uint64(m.RuntimeUser))
	}
	if m.RuntimeKernel != 0 {
		n += 1 + sovVmservice(uint64(m.RuntimeKernel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertiesVMRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovVmservice(uint64(e))
		}
		n += 1 + sovVmservice(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertiesVMResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoryStats != nil {
		l = m.MemoryStats.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.ProcessorStats != nil {
		l = m.ProcessorStats.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CapabilitiesVMResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SupportedResources) > 0 {
		for _, e := range m.SupportedResources {
			l = e.Size()
			n += 1 + l + sovVmservice(uint64(l))
		}
	}
	if len(m.SupportedGuestOs) > 0 {
		l = 0
		for _, e := range m.SupportedGuestOs {
			l += sovVmservice(uint64(e))
		}
		n += 1 + sovVmservice(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CapabilitiesVMResponse_SupportedResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Add {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.Update {
		n += 2
	}
	if m.Resource != 0 {
		n += 1 + sovVmservice(uint64(m.Resource))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HVSocketListen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceID)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.ListenerPath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VSockListen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovVmservice(uint64(m.Port))
	}
	l = len(m.ListenerPath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMSocketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovVmservice(uint64(m.Type))
	}
	if m.Config != nil {
		n += m.Config.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMSocketRequest_HvsocketList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HvsocketList != nil {
		l = m.HvsocketList.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	return n
}
func (m *VMSocketRequest_VsockListen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VsockListen != nil {
		l = m.VsockListen.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	return n
}
func (m *SCSIDisk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Controller != 0 {
		n += 1 + sovVmservice(uint64(m.Controller))
	}
	if m.Lun != 0 {
		n += 1 + sovVmservice(uint64(m.Lun))
	}
	l = len(m.HostPath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovVmservice(uint64(m.Type))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VPMEMDisk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostPath)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovVmservice(uint64(m.Type))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifySCSIDiskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovVmservice(uint64(m.Type))
	}
	if m.Disk != nil {
		l = m.Disk.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyVPMEMDiskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovVmservice(uint64(m.Type))
	}
	if m.Disk != nil {
		l = m.Disk.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NICConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NicID)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.PortID)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.SwitchID)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	l = len(m.NicName)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyNICRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovVmservice(uint64(m.Type))
	}
	if m.Nic != nil {
		l = m.Nic.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowsPCIDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyPCIDeviceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovVmservice(uint64(m.Type))
	}
	if m.WindowsPciDevice != nil {
		l = m.WindowsPciDevice.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyResourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovVmservice(uint64(m.Type))
	}
	if m.Resource != nil {
		n += m.Resource.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyResourceRequest_ScsiDisk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScsiDisk != nil {
		l = m.ScsiDisk.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	return n
}
func (m *ModifyResourceRequest_VpmemDisk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpmemDisk != nil {
		l = m.VpmemDisk.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	return n
}
func (m *ModifyResourceRequest_NicConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NicConfig != nil {
		l = m.NicConfig.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	return n
}
func (m *ModifyResourceRequest_WindowsDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowsDevice != nil {
		l = m.WindowsDevice.Size()
		n += 1 + l + sovVmservice(uint64(l))
	}
	return n
}

func sovVmservice(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVmservice(x uint64) (n int) {
	return sovVmservice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DirectBoot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectBoot{`,
		`KernelPath:` + fmt.Sprintf("%v", this.KernelPath) + `,`,
		`InitrdPath:` + fmt.Sprintf("%v", this.InitrdPath) + `,`,
		`KernelCmdline:` + fmt.Sprintf("%v", this.KernelCmdline) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UEFI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UEFI{`,
		`FirmwarePath:` + fmt.Sprintf("%v", this.FirmwarePath) + `,`,
		`DevicePath:` + fmt.Sprintf("%v", this.DevicePath) + `,`,
		`OptionalData:` + fmt.Sprintf("%v", this.OptionalData) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemoryConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemoryConfig{`,
		`MemoryMb:` + fmt.Sprintf("%v", this.MemoryMb) + `,`,
		`BackingType:` + fmt.Sprintf("%v", this.BackingType) + `,`,
		`LowMmioGapInMb:` + fmt.Sprintf("%v", this.LowMmioGapInMb) + `,`,
		`HighMmioBaseInMb:` + fmt.Sprintf("%v", this.HighMmioBaseInMb) + `,`,
		`HighMmioGapInMb:` + fmt.Sprintf("%v", this.HighMmioGapInMb) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProcessorConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProcessorConfig{`,
		`ProcessorCount:` + fmt.Sprintf("%v", this.ProcessorCount) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DevicesConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DevicesConfig{`,
		`ScsiDisks:` + strings.Replace(fmt.Sprintf("%v", this.ScsiDisks), "SCSIDisk", "SCSIDisk", 1) + `,`,
		`VpmemDisks:` + strings.Replace(fmt.Sprintf("%v", this.VpmemDisks), "VPMEMDisk", "VPMEMDisk", 1) + `,`,
		`NicConfig:` + strings.Replace(fmt.Sprintf("%v", this.NicConfig), "NICConfig", "NICConfig", 1) + `,`,
		`WindowsDevice:` + strings.Replace(fmt.Sprintf("%v", this.WindowsDevice), "WindowsPCIDevice", "WindowsPCIDevice", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VMConfig) String() string {
	if this == nil {
		return "nil"
	}
	keysForExtraData := make([]string, 0, len(this.ExtraData))
	for k, _ := range this.ExtraData {
		keysForExtraData = append(keysForExtraData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForExtraData)
	mapStringForExtraData := "map[string]string{"
	for _, k := range keysForExtraData {
		mapStringForExtraData += fmt.Sprintf("%v: %v,", k, this.ExtraData[k])
	}
	mapStringForExtraData += "}"
	s := strings.Join([]string{`&VMConfig{`,
		`MemoryConfig:` + strings.Replace(fmt.Sprintf("%v", this.MemoryConfig), "MemoryConfig", "MemoryConfig", 1) + `,`,
		`ProcessorConfig:` + strings.Replace(fmt.Sprintf("%v", this.ProcessorConfig), "ProcessorConfig", "ProcessorConfig", 1) + `,`,
		`DevicesConfig:` + strings.Replace(fmt.Sprintf("%v", this.DevicesConfig), "DevicesConfig", "DevicesConfig", 1) + `,`,
		`SerialConfig:` + strings.Replace(fmt.Sprintf("%v", this.SerialConfig), "SerialConfig", "SerialConfig", 1) + `,`,
		`BootConfig:` + fmt.Sprintf("%v", this.BootConfig) + `,`,
		`ExtraData:` + mapStringForExtraData + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VMConfig_DirectBoot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VMConfig_DirectBoot{`,
		`DirectBoot:` + strings.Replace(fmt.Sprintf("%v", this.DirectBoot), "DirectBoot", "DirectBoot", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VMConfig_Uefi) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VMConfig_Uefi{`,
		`Uefi:` + strings.Replace(fmt.Sprintf("%v", this.Uefi), "UEFI", "UEFI", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SerialConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SerialConfig{`,
		`Ports:` + strings.Replace(fmt.Sprintf("%v", this.Ports), "SerialConfig_Config", "SerialConfig_Config", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SerialConfig_Config) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SerialConfig_Config{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`SocketPath:` + fmt.Sprintf("%v", this.SocketPath) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateVMRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateVMRequest{`,
		`Config:` + strings.Replace(fmt.Sprintf("%v", this.Config), "VMConfig", "VMConfig", 1) + `,`,
		`LogID:` + fmt.Sprintf("%v", this.LogID) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InspectVMRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InspectVMRequest{`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`RecursionLimit:` + fmt.Sprintf("%v", this.RecursionLimit) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InspectVMResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InspectVMResponse{`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "Value", "types.Value", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemoryStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemoryStats{`,
		`WorkingSetBytes:` + fmt.Sprintf("%v", this.WorkingSetBytes) + `,`,
		`AvailableMemory:` + fmt.Sprintf("%v", this.AvailableMemory) + `,`,
		`ReservedMemory:` + fmt.Sprintf("%v", this.ReservedMemory) + `,`,
		`AssignedMemory:` + fmt.Sprintf("%v", this.AssignedMemory) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProcessorStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProcessorStats{`,
		`TotalRuntime:` + fmt.Sprintf("%v", this.TotalRuntime) + `,`,
		`RuntimeUser:` + fmt.Sprintf("%v", this.RuntimeUser) + `,`,
		`RuntimeKernel:` + fmt.Sprintf("%v", this.RuntimeKernel) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PropertiesVMRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PropertiesVMRequest{`,
		`Types:` + fmt.Sprintf("%v", this.Types) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PropertiesVMResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PropertiesVMResponse{`,
		`MemoryStats:` + strings.Replace(fmt.Sprintf("%v", this.MemoryStats), "MemoryStats", "MemoryStats", 1) + `,`,
		`ProcessorStats:` + strings.Replace(fmt.Sprintf("%v", this.ProcessorStats), "ProcessorStats", "ProcessorStats", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapabilitiesVMResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapabilitiesVMResponse{`,
		`SupportedResources:` + strings.Replace(fmt.Sprintf("%v", this.SupportedResources), "CapabilitiesVMResponse_SupportedResource", "CapabilitiesVMResponse_SupportedResource", 1) + `,`,
		`SupportedGuestOs:` + fmt.Sprintf("%v", this.SupportedGuestOs) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapabilitiesVMResponse_SupportedResource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapabilitiesVMResponse_SupportedResource{`,
		`Add:` + fmt.Sprintf("%v", this.Add) + `,`,
		`Remove:` + fmt.Sprintf("%v", this.Remove) + `,`,
		`Update:` + fmt.Sprintf("%v", this.Update) + `,`,
		`Resource:` + fmt.Sprintf("%v", this.Resource) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HVSocketListen) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HVSocketListen{`,
		`ServiceID:` + fmt.Sprintf("%v", this.ServiceID) + `,`,
		`ListenerPath:` + fmt.Sprintf("%v", this.ListenerPath) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VSockListen) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VSockListen{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`ListenerPath:` + fmt.Sprintf("%v", this.ListenerPath) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VMSocketRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VMSocketRequest{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Config:` + fmt.Sprintf("%v", this.Config) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VMSocketRequest_HvsocketList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VMSocketRequest_HvsocketList{`,
		`HvsocketList:` + strings.Replace(fmt.Sprintf("%v", this.HvsocketList), "HVSocketListen", "HVSocketListen", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VMSocketRequest_VsockListen) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VMSocketRequest_VsockListen{`,
		`VsockListen:` + strings.Replace(fmt.Sprintf("%v", this.VsockListen), "VSockListen", "VSockListen", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SCSIDisk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SCSIDisk{`,
		`Controller:` + fmt.Sprintf("%v", this.Controller) + `,`,
		`Lun:` + fmt.Sprintf("%v", this.Lun) + `,`,
		`HostPath:` + fmt.Sprintf("%v", this.HostPath) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`ReadOnly:` + fmt.Sprintf("%v", this.ReadOnly) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VPMEMDisk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VPMEMDisk{`,
		`HostPath:` + fmt.Sprintf("%v", this.HostPath) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`ReadOnly:` + fmt.Sprintf("%v", this.ReadOnly) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifySCSIDiskRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifySCSIDiskRequest{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Disk:` + strings.Replace(fmt.Sprintf("%v", this.Disk), "SCSIDisk", "SCSIDisk", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyVPMEMDiskRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyVPMEMDiskRequest{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Disk:` + strings.Replace(fmt.Sprintf("%v", this.Disk), "VPMEMDisk", "VPMEMDisk", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NICConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NICConfig{`,
		`NicID:` + fmt.Sprintf("%v", this.NicID) + `,`,
		`PortID:` + fmt.Sprintf("%v", this.PortID) + `,`,
		`MacAddress:` + fmt.Sprintf("%v", this.MacAddress) + `,`,
		`SwitchID:` + fmt.Sprintf("%v", this.SwitchID) + `,`,
		`NicName:` + fmt.Sprintf("%v", this.NicName) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyNICRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyNICRequest{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Nic:` + strings.Replace(fmt.Sprintf("%v", this.Nic), "NICConfig", "NICConfig", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WindowsPCIDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WindowsPCIDevice{`,
		`InstanceID:` + fmt.Sprintf("%v", this.InstanceID) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyPCIDeviceRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyPCIDeviceRequest{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`WindowsPciDevice:` + strings.Replace(fmt.Sprintf("%v", this.WindowsPciDevice), "WindowsPCIDevice", "WindowsPCIDevice", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyResourceRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyResourceRequest{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Resource:` + fmt.Sprintf("%v", this.Resource) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyResourceRequest_ScsiDisk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyResourceRequest_ScsiDisk{`,
		`ScsiDisk:` + strings.Replace(fmt.Sprintf("%v", this.ScsiDisk), "SCSIDisk", "SCSIDisk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyResourceRequest_VpmemDisk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyResourceRequest_VpmemDisk{`,
		`VpmemDisk:` + strings.Replace(fmt.Sprintf("%v", this.VpmemDisk), "VPMEMDisk", "VPMEMDisk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyResourceRequest_NicConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyResourceRequest_NicConfig{`,
		`NicConfig:` + strings.Replace(fmt.Sprintf("%v", this.NicConfig), "NICConfig", "NICConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyResourceRequest_WindowsDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyResourceRequest_WindowsDevice{`,
		`WindowsDevice:` + strings.Replace(fmt.Sprintf("%v", this.WindowsDevice), "WindowsPCIDevice", "WindowsPCIDevice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringVmservice(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}

type VMService interface {
	CreateVM(ctx context.Context, req *CreateVMRequest) (*types.Empty, error)
	TeardownVM(ctx context.Context, req *types.Empty) (*types.Empty, error)
	PauseVM(ctx context.Context, req *types.Empty) (*types.Empty, error)
	ResumeVM(ctx context.Context, req *types.Empty) (*types.Empty, error)
	WaitVM(ctx context.Context, req *types.Empty) (*types.Empty, error)
	InspectVM(ctx context.Context, req *InspectVMRequest) (*InspectVMResponse, error)
	CapabilitiesVM(ctx context.Context, req *types.Empty) (*CapabilitiesVMResponse, error)
	PropertiesVM(ctx context.Context, req *PropertiesVMRequest) (*PropertiesVMResponse, error)
	ModifyResource(ctx context.Context, req *ModifyResourceRequest) (*types.Empty, error)
	VMSocket(ctx context.Context, req *VMSocketRequest) (*types.Empty, error)
	Quit(ctx context.Context, req *types.Empty) (*types.Empty, error)
}

func RegisterVMService(srv *github_com_containerd_ttrpc.Server, svc VMService) {
	srv.Register("vmservice.VM", map[string]github_com_containerd_ttrpc.Method{
		"CreateVM": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req CreateVMRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.CreateVM(ctx, &req)
		},
		"TeardownVM": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req types.Empty
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.TeardownVM(ctx, &req)
		},
		"PauseVM": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req types.Empty
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.PauseVM(ctx, &req)
		},
		"ResumeVM": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req types.Empty
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.ResumeVM(ctx, &req)
		},
		"WaitVM": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req types.Empty
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.WaitVM(ctx, &req)
		},
		"InspectVM": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req InspectVMRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.InspectVM(ctx, &req)
		},
		"CapabilitiesVM": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req types.Empty
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.CapabilitiesVM(ctx, &req)
		},
		"PropertiesVM": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req PropertiesVMRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.PropertiesVM(ctx, &req)
		},
		"ModifyResource": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req ModifyResourceRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.ModifyResource(ctx, &req)
		},
		"VMSocket": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req VMSocketRequest
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.VMSocket(ctx, &req)
		},
		"Quit": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
			var req types.Empty
			if err := unmarshal(&req); err != nil {
				return nil, err
			}
			return svc.Quit(ctx, &req)
		},
	})
}

type vMClient struct {
	client *github_com_containerd_ttrpc.Client
}

func NewVMClient(client *github_com_containerd_ttrpc.Client) VMService {
	return &vMClient{
		client: client,
	}
}

func (c *vMClient) CreateVM(ctx context.Context, req *CreateVMRequest) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "vmservice.VM", "CreateVM", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) TeardownVM(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "vmservice.VM", "TeardownVM", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) PauseVM(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "vmservice.VM", "PauseVM", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) ResumeVM(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "vmservice.VM", "ResumeVM", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) WaitVM(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "vmservice.VM", "WaitVM", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) InspectVM(ctx context.Context, req *InspectVMRequest) (*InspectVMResponse, error) {
	var resp InspectVMResponse
	if err := c.client.Call(ctx, "vmservice.VM", "InspectVM", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) CapabilitiesVM(ctx context.Context, req *types.Empty) (*CapabilitiesVMResponse, error) {
	var resp CapabilitiesVMResponse
	if err := c.client.Call(ctx, "vmservice.VM", "CapabilitiesVM", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) PropertiesVM(ctx context.Context, req *PropertiesVMRequest) (*PropertiesVMResponse, error) {
	var resp PropertiesVMResponse
	if err := c.client.Call(ctx, "vmservice.VM", "PropertiesVM", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) ModifyResource(ctx context.Context, req *ModifyResourceRequest) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "vmservice.VM", "ModifyResource", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) VMSocket(ctx context.Context, req *VMSocketRequest) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "vmservice.VM", "VMSocket", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *vMClient) Quit(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	var resp types.Empty
	if err := c.client.Call(ctx, "vmservice.VM", "Quit", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}
func (m *DirectBoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectBoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectBoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitrdPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitrdPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelCmdline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelCmdline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEFI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEFI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEFI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirmwarePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirmwarePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevicePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevicePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMb", wireType)
			}
			m.MemoryMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryMb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingType", wireType)
			}
			m.BackingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackingType |= MemoryConfig_BackingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowMmioGapInMb", wireType)
			}
			m.LowMmioGapInMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowMmioGapInMb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighMmioBaseInMb", wireType)
			}
			m.HighMmioBaseInMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighMmioBaseInMb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighMmioGapInMb", wireType)
			}
			m.HighMmioGapInMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighMmioGapInMb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessorCount", wireType)
			}
			m.ProcessorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessorCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DevicesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DevicesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DevicesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScsiDisks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScsiDisks = append(m.ScsiDisks, &SCSIDisk{})
			if err := m.ScsiDisks[len(m.ScsiDisks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpmemDisks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpmemDisks = append(m.VpmemDisks, &VPMEMDisk{})
			if err := m.VpmemDisks[len(m.VpmemDisks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicConfig = append(m.NicConfig, &NICConfig{})
			if err := m.NicConfig[len(m.NicConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WindowsDevice = append(m.WindowsDevice, &WindowsPCIDevice{})
			if err := m.WindowsDevice[len(m.WindowsDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryConfig == nil {
				m.MemoryConfig = &MemoryConfig{}
			}
			if err := m.MemoryConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessorConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessorConfig == nil {
				m.ProcessorConfig = &ProcessorConfig{}
			}
			if err := m.ProcessorConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevicesConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DevicesConfig == nil {
				m.DevicesConfig = &DevicesConfig{}
			}
			if err := m.DevicesConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SerialConfig == nil {
				m.SerialConfig = &SerialConfig{}
			}
			if err := m.SerialConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectBoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DirectBoot{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BootConfig = &VMConfig_DirectBoot{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uefi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEFI{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BootConfig = &VMConfig_Uefi{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraData == nil {
				m.ExtraData = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVmservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVmservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVmservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthVmservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVmservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthVmservice
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthVmservice
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVmservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVmservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ExtraData[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SerialConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SerialConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SerialConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &SerialConfig_Config{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SerialConfig_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SocketPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SocketPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVMRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVMRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVMRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &VMConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectVMRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectVMRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectVMRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursionLimit", wireType)
			}
			m.RecursionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecursionLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectVMResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectVMResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectVMResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &types.Value{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingSetBytes", wireType)
			}
			m.WorkingSetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingSetBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableMemory", wireType)
			}
			m.AvailableMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableMemory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedMemory", wireType)
			}
			m.ReservedMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReservedMemory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedMemory", wireType)
			}
			m.AssignedMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedMemory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRuntime", wireType)
			}
			m.TotalRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRuntime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeUser", wireType)
			}
			m.RuntimeUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuntimeUser |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeKernel", wireType)
			}
			m.RuntimeKernel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuntimeKernel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertiesVMRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertiesVMRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertiesVMRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v PropertiesVMRequest_PropertiesType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVmservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PropertiesVMRequest_PropertiesType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVmservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVmservice
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVmservice
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]PropertiesVMRequest_PropertiesType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PropertiesVMRequest_PropertiesType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVmservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PropertiesVMRequest_PropertiesType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertiesVMResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertiesVMResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertiesVMResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryStats == nil {
				m.MemoryStats = &MemoryStats{}
			}
			if err := m.MemoryStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessorStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessorStats == nil {
				m.ProcessorStats = &ProcessorStats{}
			}
			if err := m.ProcessorStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapabilitiesVMResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapabilitiesVMResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapabilitiesVMResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportedResources = append(m.SupportedResources, &CapabilitiesVMResponse_SupportedResource{})
			if err := m.SupportedResources[len(m.SupportedResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v CapabilitiesVMResponse_SupportedGuestOS
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVmservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= CapabilitiesVMResponse_SupportedGuestOS(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedGuestOs = append(m.SupportedGuestOs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVmservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVmservice
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVmservice
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SupportedGuestOs) == 0 {
					m.SupportedGuestOs = make([]CapabilitiesVMResponse_SupportedGuestOS, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v CapabilitiesVMResponse_SupportedGuestOS
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVmservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= CapabilitiesVMResponse_SupportedGuestOS(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedGuestOs = append(m.SupportedGuestOs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedGuestOs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapabilitiesVMResponse_SupportedResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportedResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportedResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Add = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			m.Resource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resource |= CapabilitiesVMResponse_Resource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HVSocketListen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HVSocketListen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HVSocketListen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenerPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSockListen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSockListen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSockListen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenerPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMSocketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMSocketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMSocketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ModifyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HvsocketList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HVSocketListen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &VMSocketRequest_HvsocketList{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VsockListen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VSockListen{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Config = &VMSocketRequest_VsockListen{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCSIDisk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCSIDisk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCSIDisk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			m.Controller = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Controller |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lun", wireType)
			}
			m.Lun = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lun |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DiskType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPMEMDisk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPMEMDisk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPMEMDisk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DiskType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifySCSIDiskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifySCSIDiskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifySCSIDiskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ModifyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disk == nil {
				m.Disk = &SCSIDisk{}
			}
			if err := m.Disk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyVPMEMDiskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyVPMEMDiskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyVPMEMDiskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ModifyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disk == nil {
				m.Disk = &VPMEMDisk{}
			}
			if err := m.Disk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NICConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NICConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NICConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NicName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyNICRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyNICRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyNICRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ModifyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nic == nil {
				m.Nic = &NICConfig{}
			}
			if err := m.Nic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsPCIDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsPCIDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsPCIDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyPCIDeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyPCIDeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyPCIDeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ModifyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsPciDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WindowsPciDevice == nil {
				m.WindowsPciDevice = &WindowsPCIDevice{}
			}
			if err := m.WindowsPciDevice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ModifyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScsiDisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SCSIDisk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &ModifyResourceRequest_ScsiDisk{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpmemDisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VPMEMDisk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &ModifyResourceRequest_VpmemDisk{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NicConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NICConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &ModifyResourceRequest_NicConfig{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVmservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVmservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WindowsPCIDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &ModifyResourceRequest_WindowsDevice{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVmservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVmservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVmservice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVmservice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVmservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVmservice
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthVmservice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVmservice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVmservice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthVmservice
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVmservice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVmservice   = fmt.Errorf("proto: integer overflow")
)
